<!DOCTYPE html>
<html lang="en" class="index-page">
<head>
    <title>SENTION Dashboard</title>
    <link rel="icon" type="image/png" href="https://i.postimg.cc/FRwbMSBN/SENTION-logo-Black-Transparent-BG.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Popup Tooltip styles - more like the example image */
        .info-tooltip {
            position: relative;
            cursor: pointer;
            display: inline-block;
        }
        
        .navbar-links .info-tooltip {
            margin: 0 2px;
        }
        
        .navbar-links .info-tooltip a {
            display: inline-block;
            padding: 10px 15px;
            text-decoration: none;
            color: #333;
            transition: all 0.2s;
            border-radius: 4px;
            font-weight: 500;
            position: relative;
        }
        
        .navbar-links .info-tooltip a::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 10%;
            width: 80%;
            height: 2px;
            background: #8c857d;
            transform: scaleX(0);
            transition: transform 0.3s;
        }
        
        .navbar-links .info-tooltip a:hover {
            background-color: rgba(240, 244, 248, 0.5);
            color: #000;
        }
        
        .navbar-links .info-tooltip a:hover::before {
            transform: scaleX(1);
        }
        
        .navbar-links .info-tooltip a.active {
            background: linear-gradient(135deg, rgba(167, 163, 158, 0.1) 0%, rgba(140, 133, 125, 0.2) 100%);
            color: #000;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .navbar-links .info-tooltip a.active::before {
            transform: scaleX(1);
            background: linear-gradient(90deg, transparent, #8c857d, transparent);
            height: 3px;
        }
        
        /* Right nav buttons tooltip styles */
        .nav-buttons .info-tooltip {
            margin: 0 2px;
            display: inline-block;
        }
        
        .nav-buttons .info-tooltip a {
            display: inline-block;
        }
        
        .nav-buttons .info-tooltip-content {
            right: 0;
            left: auto;
            transform: none;
        }
        
        .nav-buttons .info-tooltip-content::after {
            left: 75%;
        }
        
        .info-tooltip-content {
            display: none;
            position: absolute;
            top: 100%; /* Position below the navbar instead of above */
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 200px;
            padding: 20px;
            text-align: center;
            z-index: 1000;
            margin-top: 10px; /* Add some space between navbar and tooltip */
        }
        
        /* Arrow on tooltip - pointing up instead of down */
        .info-tooltip-content::after {
            content: "";
            position: absolute;
            top: -10px; /* Position above the tooltip box */
            left: 50%;
            margin-left: -10px;
            border-width: 10px;
            border-style: solid;
            border-color: transparent transparent white transparent; /* Arrow pointing up */
        }
        
        .info-icon {
            display: block;
            width: 40px;
            height: 40px;
            background-color: #f0f0f0;
            border-radius: 50%;
            margin: 0 auto 15px;
            line-height: 40px;
            font-size: 18px;
        }
        
        .info-tooltip-text {
            color: #333;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        /* Show the tooltip when hovering */
        .info-tooltip:hover .info-tooltip-content {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes tooltip-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Rating selector styles */
        .rating-selector {
            position: absolute;
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 10px;
            z-index: 1000;
            display: none;
        }
        
        .rating-option {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .rating-option:hover {
            background-color: #f0f0f0;
        }
        
        .rating-option.highlighted {
            background-color: #e0f0ff;
        }
        
        /* Intervention icon button styles */
        .intervention-btn {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: #5D6D7E; /* √Ñndrat till en mer diskret m√∂rk bl√•gr√• ton */
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .intervention-btn:hover {
            background-color: #34495E; /* M√∂rkare diskret ton vid hover */
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        .intervention-btn i {
            font-size: 24px;
        }
        
        /* Intervention panel styles */
        .intervention-panel {
            display: none;
            position: fixed;
            bottom: 90px;
            left: 30px;
            width: 350px;
            max-height: 70vh;
            overflow-y: auto;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
            z-index: 999;
            padding: 20px;
        }
        
        .intervention-panel.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }
        
        .intervention-panel h3 {
            margin-top: 0;
            color: #333;
            font-weight: 600;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
            color: #5D6D7E; /* √Ñndrat till samma diskreta ton */
        }
        
        .intervention-category {
            margin-bottom: 20px;
            border-left: 3px solid #5D6D7E; /* √Ñndrat till samma diskreta ton */
            padding-left: 12px;
        }
        
        .intervention-category h4 {
            color: #5D6D7E; /* √Ñndrat till samma diskreta ton */
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .intervention-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .intervention-item {
            padding: 8px 12px;
            margin-bottom: 6px;
            background-color: #f5f5f5;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            position: relative;
        }
        
        .intervention-item:hover {
            background-color: #EBF0F5; /* √Ñndrat till en ljusare diskret bl√•gr√• */
            transform: translateX(5px);
        }
        
        /* Style for copied items to provide visual feedback */
        .intervention-item.copied {
            background-color: #e0f3e0; /* Light green background */
            border-left: 3px solid #28a745; /* Green border */
            animation: highlight-copied 2s ease;
        }
        
        @keyframes highlight-copied {
            0% { background-color: #c8e6c9; }
            100% { background-color: #e0f3e0; }
        }
        
        /* Add specific styles for the delete button in intervention items */
        .delete-intervention {
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s ease;
            z-index: 10;
            position: relative;
            padding: 5px;
        }
        
        .delete-intervention:hover {
            opacity: 1;
            transform: scale(1.2);
            color: #b30000 !important;
        }
        
        /* Tooltip style modifications */
        .copy-tooltip {
            animation-duration: 3s !important; /* Extended from default */
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }
        
        /* Add a little arrow to the tooltip */
        .copy-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
        }
        
        .intervention-item i {
            margin-right: 10px;
            color: #5D6D7E; /* √Ñndrat till samma diskreta ton */
        }
        
        .intervention-item .copy-btn {
            position: absolute;
            right: 10px;
            background: transparent;
            border: none;
            color: #5D6D7E;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .intervention-item:hover .copy-btn {
            opacity: 1;
        }
        
        /* Copy tooltip styles */
        .copy-tooltip {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(93, 109, 126, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            animation: fadeInOut 2s forwards;
        }
        
        /* Copied state styles */
        .intervention-item.copied {
            background-color: rgba(93, 109, 126, 0.2);
            box-shadow: 0 0 0 2px rgba(93, 109, 126, 0.5);
        }
        
        /* Animation for the tooltip */
        @keyframes fadeInOut {
            0% { opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Add button styles */
        .add-item-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border-radius: 6px;
            background-color: #F0EEEC;
            color: #333;
            border: none;
            cursor: pointer;
            margin: 10px auto;
        }

        .add-item-btn:hover {
            background-color: #e0dedc;
        }

        /* Item styles */
        .item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin: 5px;
            background-color: #F7F6F5;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: default;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .item:hover {
            background-color: #F0EEEC;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        /* Drag handle styles */
        .drag-handle {
            cursor: grab;
            color: #6c757d;
            padding: 5px;
            margin-right: 5px;
            opacity: 0.5;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        
        .drag-handle:hover {
            opacity: 1;
            transform: scale(1.2);
            color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.1);
            border-radius: 4px;
        }
        
        .drag-handle:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        
        .drag-handle::after {
            content: 'Dra f√∂r att √§ndra ordning';
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            z-index: 1000;
        }
        
        .drag-handle:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        /* Dragging styles */
        .item.dragging {
            background-color: rgba(13, 110, 253, 0.1) !important;
            opacity: 0.8;
            cursor: grabbing;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transform: scale(1.02);
            border: 1px dashed #0d6efd;
            z-index: 100;
        }
        
        .item.drag-over {
            position: relative;
        }
        
        .item.drag-over::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: -2px;
            height: 4px;
            background-color: #0d6efd;
            z-index: 100;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            animation: pulse 1.5s infinite;
        }

        /* Container drag-over styles */
        .items-container.container-drag-over {
            background-color: rgba(13, 110, 253, 0.1);
            border: 2px dashed #0d6efd;
            border-radius: 6px;
            padding: 10px;
            min-height: 60px;
            animation: pulse 1.5s infinite;
        }

        /* Empty container styles */
        .items-container {
            width: 100%;
            min-height: 50px; /* Ensure empty containers have some height */
            transition: all 0.2s ease;
        }

        .item-text {
            flex-grow: 1;
            margin-right: 10px;
            min-height: 20px;
        }

        .item-text[contenteditable="true"] {
            padding: 2px;
            outline: none;
        }

        .item-rating {
            padding: 2px 5px;
            color: #666;
            min-width: 60px;
            text-align: center;
        }
        
        /* Add placeholder for empty rating */
        .item-rating:empty::before {
            content: "Klicka f√∂r betyg";
            font-style: italic;
            color: #aaa;
            font-size: 0.85em;
        }

        /* Delete button styles */
        .delete-btn {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .item:hover .delete-btn {
            opacity: 1;
        }
        
        .delete-btn:hover {
            color: #bd2130;
        }

        /* Edit mode styles */
        .editing {
            background-color: #fff;
            box-shadow: 0 0 0 2px #007bff;
        }

        .editing .delete-btn {
            opacity: 1;
        }

        /* Entity row styles */
        .entity-row {
            margin: 20px;
            width: calc(100% - 40px); /* Full width minus margins */
            max-width: 100%;
            box-sizing: border-box;
        }

        .risk-columns {
            display: flex;
            gap: 20px;
            width: 100%;
            margin-top: 10px;
        }

        .risk-column {
            flex: 1;
            border-radius: 8px;
            padding: 15px;
            min-width: 0; /* Prevents flex items from overflowing */
        }

        .risk-column.no-risk {
            background-color: rgba(40, 167, 69, 0.1); /* Light green */
        }

        .risk-column.at-risk {
            background-color: rgba(255, 193, 7, 0.1); /* Light yellow */
        }

        .risk-column.high-risk {
            background-color: rgba(220, 53, 69, 0.1); /* Light red */
        }

        /* Cell being edited styles */
        .cell-editing {
            background-color: rgba(255, 255, 0, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5);
            position: relative;
        }

        .cell-editing::after {
            content: "Redigeras...";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        /* Cell being edited by another user */
        .cell-editing-other {
            background-color: rgba(255, 0, 0, 0.1) !important;
            position: relative;
        }

        .cell-editing-other::after {
            content: "Redigeras av annan anv√§ndare";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        /* Status message styles */
        .status-message {
            margin: 15px 20px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        
        .success-message {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* Auto-save indicator */
        .auto-save-indicator {
            display: inline-block;
            margin: 15px 20px;
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        /* Saving animation */
        .saving {
            display: inline-block;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        /* First-time user hint */
        .drag-hint {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            padding: 20px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            max-width: 450px; /* √ñka fr√•n tidigare v√§rde */
            width: 90%;
            max-height: 80vh; /* Begr√§nsa h√∂jden s√• att den inte tar upp hela sk√§rmen */
            overflow-y: auto; /* L√§gg till scrollning om inneh√•llet blir f√∂r stort */
        }
        
        .drag-hint-content {
            margin-bottom: 15px;
            font-size: 15px; /* √ñka textstorleken lite */
            line-height: 1.5; /* √ñka radavst√•ndet f√∂r b√§ttre l√§sbarhet */
            position: relative;
            padding: 0 5px;
        }
        
        #drag-hint-text {
            display: block;
            padding: 8px 0;
            transition: opacity 0.3s ease;
            opacity: 1;
        }
        
        #drag-hint-text.fade {
            opacity: 0;
        }
        
        /* Icon styling in tips */
        #drag-hint-text i {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: -0.125em;
            margin: 0 3px;
        }
        
        .drag-hint-tip {
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
        }
        
        /* Improved tip navigation styling */
        .tip-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 12px;
            border-top: 1px solid #eee;
            padding-top: 12px;
        }
        
        .tip-nav-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background-color: #f0f7ff;
            border: 1px solid #d0e3ff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #0d6efd;
            font-size: 0.9rem;
            padding: 0;
            margin: 0 8px;
        }
        
        .tip-nav-btn:hover {
            background-color: #e0f0ff;
            transform: scale(1.05);
        }
        
        .tip-nav-btn:active {
            transform: scale(0.95);
        }
        
        .tip-counter {
            font-size: 14px;
            color: #6c757d;
            margin: 0 10px;
            min-width: 40px;
            text-align: center;
        }
        
        .drag-hint i {
            font-size: 1.2rem;
            color: #0d6efd;
        }
        
        .drag-hint-close {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            color: #999;
            transition: color 0.2s;
            font-size: 16px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .drag-hint-close:hover {
            color: #666;
            background-color: #f0f0f0;
        }
        
        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 1050;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: #333;
        }
        
        .shortcuts-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .shortcuts-table tr {
            border-bottom: 1px solid #eee;
        }
        
        .shortcuts-table tr:last-child {
            border-bottom: none;
        }
        
        .shortcuts-table td {
            padding: 8px 5px;
        }
        
        .shortcuts-table td:first-child {
            width: 40%;
            text-align: right;
            padding-right: 15px;
        }
        
        kbd {
            background-color: #f7f7f7;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
            color: #333;
            display: inline-block;
            font-size: 0.85em;
            font-family: monospace;
            line-height: 1;
            padding: 2px 5px;
            margin: 0 2px;
        }
        
        /* Help button styles */
        .help-btn {
            background-color: #6c757d;
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            text-decoration: none;
            margin-left: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            transition: background-color 0.2s;
        }
        
        .help-btn:hover {
            background-color: #5a6268;
            color: white;
        }
        
        .help-btn i {
            font-size: 1.1rem;
        }
        
        /* Welcome modal styles */
        .welcome-content {
            max-width: 600px;
            padding: 25px;
        }
        
        .welcome-steps {
            margin: 20px 0;
        }
        
        .welcome-step {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }
        
        .step-number {
            background-color: #0d6efd;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex-grow: 1;
        }
        
        .step-content h4 {
            margin: 0 0 5px 0;
            color: #333;
        }
        
        .step-content p {
            margin: 0;
            color: #666;
            line-height: 1.5;
        }
        
        .welcome-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        .welcome-btn {
            background-color: #0d6efd;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .welcome-btn:hover {
            background-color: #0b5ed7;
        }
        
        .dont-show-again {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #666;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* Help floating button */
        .help-floating-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #0d6efd;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 999;
            transition: all 0.2s;
            opacity: 0;
            visibility: hidden;
        }
        
        .help-floating-btn.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .help-floating-btn:hover {
            transform: scale(1.1);
            background-color: #0b5ed7;
        }
        
        .help-floating-btn i {
            font-size: 1.2rem;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Container styles to ensure consistent margins */
        .container {
            margin: 0 20px;
            width: calc(100% - 40px);
            box-sizing: border-box;
        }

        /* Search container styles */
        .search-container {
            margin-bottom: 15px;
        }
        
        .intervention-search {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .intervention-search:focus {
            border-color: #5D6D7E; /* √Ñndrat till samma diskreta ton */
            box-shadow: 0 0 0 2px rgba(93, 109, 126, 0.2); /* √Ñndrat till samma diskreta ton */
            outline: none;
        }
        
        /* Custom intervention styles */
        .add-custom-intervention {
            display: flex;
            margin-top: 10px;
        }
        
        .add-custom-intervention input {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 6px 0 0 6px;
            font-size: 14px;
        }
        
        .add-custom-intervention input:focus {
            border-color: #5D6D7E; /* √Ñndrat till samma diskreta ton */
            outline: none;
        }
        
        .add-custom-intervention button {
            background-color: #5D6D7E; /* √Ñndrat till samma diskreta ton */
            color: white;
            border: none;
            border-radius: 0 6px 6px 0;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .add-custom-intervention button:hover {
            background-color: #34495E; /* √Ñndrat till m√∂rkare diskret ton vid hover */
        }
        
        /* No results message */
        .no-results {
            padding: 10px;
            text-align: center;
            color: #666;
            font-style: italic;
            display: none;
        }
        
        /* Drag and drop styles for risk cells */
        .no-risk, .at-risk, .high-risk {
            position: relative;
            transition: background-color 0.2s ease;
        }
        
        .container-drag-over {
            background-color: rgba(93, 109, 126, 0.1) !important;
            border: 2px dashed #5D6D7E !important;
            border-radius: 6px;
            padding: 10px;
            min-height: 60px;
            animation: pulse 1.5s infinite;
        }
        
        .item.dragging {
            background-color: rgba(0, 123, 255, 0.1) !important;
            opacity: 0.8;
            cursor: move;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        .item.drag-over {
            position: relative;
        }
        
        .item.drag-over::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: -2px;
            height: 4px;
            background-color: #0d6efd;
            z-index: 100;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        /* Intervention in risk cell styles */
        .item[data-item-id^="intervention_"] {
            background-color: #f8f9fa;
            border-left: 3px solid #5D6D7E;
        }
        
        .item[data-item-id^="intervention_"] .item-content {
            display: flex;
            align-items: center;
        }
        
        .item[data-item-id^="intervention_"]:hover {
            background-color: #EBF0F5;
        }

        /* F√∂r att positionera ikoner i tips */
        .tip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            margin-right: 6px;
            vertical-align: middle;
        }

        /* Justera drag-hint-navigation f√∂r att b√§ttre passa st√∂rre ruta */
        .drag-hint-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
        }

        /* Ensure copy button is properly styled */
        .copy-btn {
            background: transparent;
            border: none;
            color: #5D6D7E;
            cursor: pointer;
            margin-left: 5px;
            padding: 3px 6px;
            border-radius: 3px;
        }
        
        .copy-btn:hover {
            background-color: rgba(93, 109, 126, 0.1);
        }
    </style>
</head>
<body class="luxury-dashboard">
    <div class="header">
        <h2>SENTION</h2>
        <div class="navbar-links">
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='anstalld') }}" class="{{ 'active' if current_category == 'anstalld' else '' }}">
                    Anst√§lld
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-person"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information relaterad till individuella medarbetare och deras specifika h√§lsosituationer
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='grupp') }}" class="{{ 'active' if current_category == 'grupp' else '' }}">
                    Grupp
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-people"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information relaterad till arbetsgrupper och deras gemensamma h√§lsostatus
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='organisation') }}" class="{{ 'active' if current_category == 'organisation' else '' }}">
                    Organisation
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-building"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar √∂vergripande information f√∂r hela organisationen och dess h√§lsosituation
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='foretagsledning') }}" class="{{ 'active' if current_category == 'foretagsledning' else '' }}">
                    F√∂retagsledning
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-briefcase"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information specifikt relaterad till f√∂retagets ledningsgrupp
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='managers') }}" class="{{ 'active' if current_category == 'managers' else '' }}">
                    Managers
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-person-badge"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information relaterad till chefer
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='supervisors') }}" class="{{ 'active' if current_category == 'supervisors' else '' }}">
                    Supervisors
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-person-check"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information relaterad till handledare
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='system') }}" class="{{ 'active' if current_category == 'system' else '' }}">
                    System
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-gear"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar systemrelaterad information och inst√§llningar
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('dashboard') }}" class="{{ 'active' if current_category == 'dashboard' else '' }}">
                    Dashboard
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-speedometer2"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar sammanfattande information och insikter fr√•n alla sektioner
                    </div>
                </div>
            </div>
        </div>
        <div class="nav-buttons">
            <div class="info-tooltip">
                <a href="{{ url_for('profile') }}" class="profile-btn"><i class="bi bi-person"></i> Min profil</a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-person"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Hantera din anv√§ndarprofil och personliga inst√§llningar
                    </div>
                </div>
            </div>
            
            {% if session.role == 'admin' %}
            <div class="info-tooltip">
                <a href="{{ url_for('admin_users') }}" class="admin-btn"><i class="bi bi-gear"></i> Anv√§ndarhantering</a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-gear"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Administrera anv√§ndare, beh√∂righeter och systemfunktioner
                    </div>
                </div>
            </div>
            {% endif %}
            
            <div class="info-tooltip">
                <a href="{{ url_for('logout') }}" class="logout-btn"><i class="bi bi-box-arrow-right"></i> Logga ut</a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-box-arrow-right"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Logga ut fr√•n systemet och avsluta din session
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main content rows -->
    <div class="entity-row" data-category="{{ current_category }}">
        <div class="entity-title">HR</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>üü¢ Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>üü° Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>üî¥ H√∂g risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">‚ûï R√§tt riskgrupp i r√§tt tid</div>
            <div class="indicator">‚ûï‚ûï Anv√§nds i √∂nskad utstr√§ckning</div>
            <div class="indicator">‚ûï‚ûï‚ûï Har avsedd effekt</div>
        </div>
    </div>

    <!-- Company Health Row -->
    <div class="entity-row" data-category="{{ current_category }}">
        <div class="entity-title">F√∂retagsh√§lsov√•rd</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>üü¢ Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'F√∂retagsh√§lsov√•rd', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>üü° Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'F√∂retagsh√§lsov√•rd', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>üî¥ H√∂g risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'F√∂retagsh√§lsov√•rd', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">‚ûï R√§tt riskgrupp i r√§tt tid</div>
            <div class="indicator">‚ûï‚ûï Anv√§nds i √∂nskad utstr√§ckning</div>
            <div class="indicator">‚ûï‚ûï‚ûï Har avsedd effekt</div>
        </div>
    </div>

    <!-- Other Providers Row -->
    <div class="entity-row" data-category="{{ current_category }}">
        <div class="entity-title">Andra leverant√∂rer</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>üü¢ Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Andra leverant√∂rer', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>üü° Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Andra leverant√∂rer', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>üî¥ H√∂g risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Andra leverant√∂rer', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">‚ûï R√§tt riskgrupp i r√§tt tid</div>
            <div class="indicator">‚ûï‚ûï Anv√§nds i √∂nskad utstr√§ckning</div>
            <div class="indicator">‚ûï‚ûï‚ûï Har avsedd effekt</div>
        </div>
    </div>

    <!-- Status message and auto-save indicator -->
    <div class="container">
        <div id="auto-save-indicator" class="auto-save-indicator"></div>
        <div id="status-message" class="status-message"></div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div id="delete-confirm-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal" onclick="closeDeleteModal()">&times;</span>
            <h4>Bekr√§fta borttagning</h4>
            <p>√Ñr du s√§ker p√• att du vill ta bort detta objekt?</p>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeDeleteModal()">Avbryt</button>
                <button class="btn btn-danger" onclick="confirmDelete()">Ta bort</button>
            </div>
        </div>
    </div>
    
    <!-- Drag hint for first-time users -->
    <div id="drag-hint" class="drag-hint" style="display: none;">
        <span class="drag-hint-close" onclick="closeDragHint()">‚úï</span>
        <h4 style="margin-top: 0; color: #0d6efd;"><i class="bi bi-lightbulb"></i> Tips &amp; Hj√§lp</h4>
        <div class="drag-hint-content">
            <span id="drag-hint-text">Du kan dra i cellen f√∂r att √§ndra ordning p√• objekten</span>
            <div class="tip-navigation">
                <button class="tip-nav-btn" onclick="previousTip()"><i class="bi bi-chevron-left"></i></button>
                <span class="tip-counter"><span id="current-tip">1</span>/<span id="total-tips">6</span></span>
                <button class="tip-nav-btn" onclick="nextTip()"><i class="bi bi-chevron-right"></i></button>
            </div>
        </div>
    </div>
    
    <!-- Help floating button -->
    <div id="help-floating-btn" class="help-floating-btn visible" onclick="showDragHint(true)">
        <i class="bi bi-lightbulb"></i>
    </div>
    
    <!-- Keyboard shortcuts modal -->
    <div id="shortcuts-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal" onclick="closeShortcutsModal()">&times;</span>
            <h3>Tangentbordsgenv√§gar</h3>
            <table class="shortcuts-table">
                <tr>
                    <td><kbd>Enter</kbd></td>
                    <td>Avsluta redigering och spara</td>
                </tr>
                <tr>
                    <td><kbd>Esc</kbd></td>
                    <td>Avbryt redigering</td>
                </tr>
                <tr>
                    <td><kbd>Tab</kbd></td>
                    <td>G√• till n√§sta objekt</td>
                </tr>
                <tr>
                    <td><kbd>Shift</kbd> + <kbd>Tab</kbd></td>
                    <td>G√• till f√∂reg√•ende objekt</td>
                </tr>
                <tr>
                    <td><kbd>Ctrl</kbd> + <kbd>S</kbd></td>
                    <td>Spara alla √§ndringar manuellt</td>
                </tr>
                <tr>
                    <td><kbd>Ctrl</kbd> + <kbd>N</kbd></td>
                    <td>L√§gg till nytt objekt</td>
                </tr>
                <tr>
                    <td><kbd>Delete</kbd></td>
                    <td>Ta bort markerat objekt</td>
                </tr>
                <tr>
                    <td><kbd>?</kbd></td>
                    <td>Visa denna hj√§lp</td>
                </tr>
            </table>
        </div>
    </div>
    
    <!-- Welcome tutorial modal -->
    <div id="welcome-modal" class="modal" style="display: none;">
        <div class="modal-content welcome-content">
            <span class="close-modal" onclick="closeWelcomeModal()">&times;</span>
            <h3>V√§lkommen till SENTION Kartl√§ggning!</h3>
            <div class="welcome-steps">
                <div class="welcome-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>L√§gg till objekt</h4>
                        <p>Klicka p√• <strong>+</strong> knappen i respektive kolumn f√∂r att l√§gga till ett nytt objekt.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Redigera text</h4>
                        <p>Klicka p√• texten f√∂r att redigera den. Tryck <kbd>Enter</kbd> n√§r du √§r klar.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>S√§tt betyg</h4>
                        <p>Klicka p√• betygsomr√•det f√∂r att v√§lja ett betyg fr√•n listan.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>√Ñndra ordning</h4>
                        <p>Dra i handtaget <i class="bi bi-grip-vertical"></i> f√∂r att √§ndra ordning p√• objekten. H√•ll muspekaren √∂ver handtaget tills den visar ett <strong>grab</strong>-ikon och dra sedan objektet till √∂nskad position.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h4>Flytta till annan riskniv√•</h4>
                        <p>Du kan dra objekt mellan de olika riskkolumnerna (üü¢, üü°, üî¥) f√∂r att √§ndra riskniv√•. Anv√§nd samma draghandtag <i class="bi bi-grip-vertical"></i> f√∂r denna funktion.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">6</div>
                    <div class="step-content">
                        <h4>Automatisk sparning</h4>
                        <p>Alla √§ndringar sparas automatiskt. Du kan se status i botten av sidan.</p>
                    </div>
                </div>
            </div>
            <div class="welcome-footer">
                <button class="welcome-btn" onclick="closeWelcomeModal()">Kom ig√•ng</button>
                <label class="dont-show-again">
                    <input type="checkbox" id="dont-show-welcome" onchange="updateWelcomePreference()">
                    Visa inte igen
                </label>
            </div>
        </div>
    </div>

    <!-- Rating selector popup -->
    <div id="rating-selector" class="rating-selector">
        <div class="rating-option" onclick="selectRating('‚ûï')">‚ûï R√§tt riskgrupp i r√§tt tid</div>
        <div class="rating-option" onclick="selectRating('‚ûï‚ûï')">‚ûï‚ûï Anv√§nds i √∂nskad utstr√§ckning</div>
        <div class="rating-option" onclick="selectRating('‚ûï‚ûï‚ûï')">‚ûï‚ûï‚ûï Har avsedd effekt</div>
        <div class="rating-option" onclick="selectRating('')">Ingen bed√∂mning</div>
    </div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = '{{ supabase_url }}';
        const supabaseKey = '{{ supabase_key }}';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
        const currentCategory = "{{ current_category }}";
        
        // Auto-save variables
        let saveTimeout = null;
        const saveDelay = 1000; // 1 second delay before saving
        
        // Current cell being rated
        let currentRatingCell = null;
        
        // Track currently editing cell
        let currentlyEditingCell = null;
        let isCurrentlySaving = false;
        
        // Track cells being edited by other users
        const cellsBeingEditedByOthers = new Map(); // Map of "entityId-riskLevel-itemId" to user ID
        
        // Generate a unique user ID for this session
        const sessionUserId = generateUUID();
        
        // Drag and drop variables
        let draggedItem = null;
        let isDragging = false;

        // Setup for drag and drop
        document.addEventListener('mouseup', function() {
            // Reset dragging state when mouse is released
            isDragging = false;
            // Reset draggable attributes after a short delay to prevent issues
            setTimeout(() => {
                if (!isDragging && draggedItem) {
                    draggedItem.setAttribute('draggable', 'false');
                    draggedItem = null;
                }
            }, 100);
        });
        
        // Set up Supabase realtime subscription
        function setupRealtimeSubscription() {
            console.log("Setting up realtime subscription...");
            
            // Subscribe to changes in the items table
            const channel = supabaseClient.channel('items_changes')
                .on(
                    'postgres_changes',
                    {
                        event: '*', // Listen for all events (INSERT, UPDATE, DELETE)
                    schema: 'public',
                        table: 'items'
                    },
                    (payload) => {
                        console.log('Change received!', payload);
                        // Only reload if we're not currently saving
                        if (!isCurrentlySaving) {
                    handleRealtimeChange(payload);
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Subscription status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('Successfully subscribed to realtime changes!');
                    }
                });
                
            // Also subscribe to the editing status channel
            const editingChannel = supabaseClient.channel('editing_status')
                .on(
                    'broadcast',
                    { event: 'editing' },
                    (payload) => {
                        handleEditingStatus(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'rating_change' },
                    (payload) => {
                        handleRatingChange(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'item_deletion' },
                    (payload) => {
                        handleItemDeletion(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'new_item' },
                    (payload) => {
                        handleNewItem(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'item_move' },
                    (payload) => {
                        handleItemMove(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'item_reorder' },
                    (payload) => {
                        handleItemReorder(payload);
                    }
                )
                .subscribe();
                
            // Set up a heartbeat to keep editing status alive
            setInterval(() => {
                if (currentlyEditingCell) {
                    // Re-broadcast our editing status every 5 seconds to keep it alive
                    broadcastEditingStatus(currentlyEditingCell, true);
                }
            }, 5000);
            
            return [channel, editingChannel];
        }
        
        // Handle realtime changes
        function handleRealtimeChange(payload) {
            console.log('Handling realtime change:', payload);
            
            // Don't reload if we're currently editing a cell
            if (currentlyEditingCell) {
                console.log('Not reloading because user is editing a cell');
                return;
            }
            
            // Instead of reloading the entire page, fetch only the updated data
            fetch(`/get_items?category=${currentCategory}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Sort items by position before updating DOM
                        data.items.sort((a, b) => {
                            // First group by entity and risk_level
                            if (a.entity !== b.entity) return a.entity.localeCompare(b.entity);
                            if (a.risk_level !== b.risk_level) return a.risk_level.localeCompare(b.risk_level);
                            // Then sort by position
                            return a.position - b.position;
                        });
                        
                        // Update the DOM with the sorted items
                        updateItemsInDOM(data.items);
                        
                        // Show a subtle notification that content was updated
                        const autoSaveIndicator = document.getElementById('auto-save-indicator');
                        autoSaveIndicator.innerHTML = 'Inneh√•ll uppdaterat';
                        setTimeout(() => {
                            autoSaveIndicator.innerHTML = '';
                        }, 2000);
                    } else {
                        console.error('Error fetching updated items:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error fetching updated items:', error);
                });
        }
        
        // Function to update items in the DOM without reloading the page
        function updateItemsInDOM(items) {
            console.log('Updating items in DOM with server data');
            
            // Create a map of existing items for quick lookup
            const existingItemsMap = new Map();
            document.querySelectorAll('.item').forEach(item => {
                const itemId = item.getAttribute('data-item-id');
                existingItemsMap.set(itemId, item);
            });
            
            // Create a map of updated items
            const updatedItemsMap = new Map();
            items.forEach(item => {
                if (item.category === currentCategory) {
                    updatedItemsMap.set(item.id, item);
                }
            });
            
            // First pass: Update or add items
            items.forEach(item => {
                if (item.category === currentCategory) {
                    const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
                    
                    // Skip if this item is currently being edited
                    if (existingItem && (existingItem.querySelector('.cell-editing') || existingItem.querySelector('.cell-editing-other'))) {
                        return;
                    }
                    
                    // Find the correct container
                    const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
            
                    if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                
                        if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                    
                            if (existingItem) {
                                // Check if the item needs to be moved to a different container
                                const currentContainer = existingItem.parentNode;
                                const currentRiskLevel = existingItem.getAttribute('data-risk');
                                
                                if (currentRiskLevel !== item.risk_level) {
                                    // Item has moved to a different risk level
                                    existingItem.remove();
                                    existingItem.setAttribute('data-risk', item.risk_level);
                                    
                                    // Add to new container at the correct position
                                    if (item.position === 0) {
                                        // Special case for position 0
                                        container.insertBefore(existingItem, container.firstChild);
                                    } else if (container.children.length > item.position) {
                                        container.insertBefore(existingItem, container.children[item.position]);
                                    } else {
                                        container.appendChild(existingItem);
                                    }
                                    
                                    // Store position for verification
                                    existingItem.setAttribute('data-position', item.position.toString());
                                } else if (currentContainer === container) {
                                    // Item is in the correct container, but might need reordering
                                    const currentIndex = Array.from(container.children).indexOf(existingItem);
                                    if (currentIndex !== item.position) {
                                        // Remove and reinsert at the correct position
                                        existingItem.remove();
                                        
                                        if (item.position === 0) {
                                            // Special case for position 0
                                            container.insertBefore(existingItem, container.firstChild);
                                        } else if (container.children.length > item.position) {
                                            container.insertBefore(existingItem, container.children[item.position]);
                                        } else {
                                            container.appendChild(existingItem);
                                        }
                                        
                                        // Store position for verification
                                        existingItem.setAttribute('data-position', item.position.toString());
                                    }
                                }
                                
                                // Update content
                                const textElement = existingItem.querySelector('.item-text');
                                const ratingElement = existingItem.querySelector('.item-rating');
                                
                                // Only update if not being edited
                                if (!textElement.classList.contains('cell-editing') && !textElement.classList.contains('cell-editing-other')) {
                                    textElement.textContent = item.text;
                                }
                                
                                ratingElement.textContent = item.rating || '';
                            } else {
                                // Create new item
                                const itemElement = document.createElement('div');
                                itemElement.className = 'item';
                                itemElement.setAttribute('draggable', 'false');
                                itemElement.setAttribute('data-entity', item.entity);
                                itemElement.setAttribute('data-risk', item.risk_level);
                                itemElement.setAttribute('data-item-id', item.id || generateUUID());
                                itemElement.setAttribute('data-position', item.position.toString());
                                itemElement.setAttribute('data-category', item.category);
                                
                                // Use empty string if rating is null, undefined, or empty
                                const ratingValue = item.rating || '';
                                
                                itemElement.innerHTML = `
                                    <i class="bi bi-grip-vertical drag-handle" title="Dra f√∂r att √§ndra ordning"></i>
                                    <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text}</div>
                                    <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                                    <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                                `;
                                
                                // Add to container at the correct position
                                if (item.position === 0) {
                                    // Special case for position 0
                                    container.insertBefore(itemElement, container.firstChild);
                                } else if (container.children.length > item.position) {
                                    container.insertBefore(itemElement, container.children[item.position]);
                                } else {
                                    container.appendChild(itemElement);
                                }
                                
                                // Add click handler to make text editable when clicked
                                const textElement = itemElement.querySelector('.item-text');
                                textElement.addEventListener('click', function(e) {
                                    // Prevent editing if cell is being edited by another user
                                    if (textElement.classList.contains('cell-editing-other')) {
                                        e.preventDefault();
                                        return;
                                    }
                                    
                                    if (textElement.getAttribute('contenteditable') === 'false') {
                                        textElement.setAttribute('contenteditable', 'true');
                                        textElement.focus();
                                    }
                                });
                                
                                // Initialize drag and drop for this item
                                initializeDragForItem(itemElement);
                            }
                        }
                    }
                }
            });
            
            // Second pass: Remove items that no longer exist in the updated data
            existingItemsMap.forEach((itemElement, itemId) => {
                // Skip if this item is currently being edited
                if (itemElement.querySelector('.cell-editing') || itemElement.querySelector('.cell-editing-other')) {
                    return;
                }
                
                // If the item doesn't exist in the updated data, remove it
                if (!updatedItemsMap.has(itemId)) {
                    itemElement.remove();
                }
            });
            
            // Re-apply editing indicators
            applyEditingIndicators();
            
            // Verification step: check if all items are in their expected positions
            let hasPositionMismatch = false;
            document.querySelectorAll('.item').forEach(item => {
                const expectedPosition = parseInt(item.getAttribute('data-position'), 10);
                if (!isNaN(expectedPosition)) {
                    const container = item.parentNode;
                    const actualPosition = Array.from(container.children).indexOf(item);
                    if (expectedPosition !== actualPosition) {
                        console.warn(`Position mismatch for item ${item.getAttribute('data-item-id')}: expected ${expectedPosition}, got ${actualPosition}`);
                        hasPositionMismatch = true;
                    }
                }
            });
            
            if (hasPositionMismatch) {
                console.warn('Position mismatches detected. Consider refreshing to ensure correct positioning.');
            }
        }
        
        // Handle editing status updates
        function handleEditingStatus(payload) {
            console.log('Editing status update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { userId, entityId, riskLevel, itemId, isEditing, newText } = payload.payload;
            const cellKey = `${entityId}-${riskLevel}-${itemId}`;
            
            // Find the cell
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                const textCell = item.querySelector('.item-text');
                
                if (isEditing) {
                    // Another user is editing this cell
                    textCell.classList.add('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Prevent editing
                    
                    // Remove any click handlers that might enable editing
                    const newTextCell = textCell.cloneNode(true);
                    textCell.parentNode.replaceChild(newTextCell, textCell);
                    
                    // Store in our map of cells being edited
                    cellsBeingEditedByOthers.set(cellKey, userId);
                } else {
                    // User stopped editing
                    textCell.classList.remove('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Keep it non-editable by default
                    
                    // If we received new text, update the cell content
                    if (newText !== undefined) {
                        textCell.textContent = newText;
                    }
                    
                    // Add click handler to make it editable again when clicked
                    const newTextCell = textCell.cloneNode(true);
                    newTextCell.addEventListener('click', function(e) {
                        // Prevent editing if cell is being edited by another user
                        if (newTextCell.classList.contains('cell-editing-other')) {
                            e.preventDefault();
                            return;
                        }
                        
                        if (newTextCell.getAttribute('contenteditable') === 'false') {
                            newTextCell.setAttribute('contenteditable', 'true');
                            newTextCell.focus();
                        }
                    });
                    textCell.parentNode.replaceChild(newTextCell, textCell);
                    
                    // Remove from our map
                    cellsBeingEditedByOthers.delete(cellKey);
                    
                    // Show a subtle notification that content was updated
                    const autoSaveIndicator = document.getElementById('auto-save-indicator');
                    autoSaveIndicator.innerHTML = 'Inneh√•ll uppdaterat';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            }
        }
        
        // Handle rating change
        function handleRatingChange(payload) {
            console.log('Rating change update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId, rating } = payload.payload;
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                const ratingCell = item.querySelector('.item-rating');
                
                // Update the rating
                ratingCell.textContent = rating;
                
                // Show a subtle notification that content was updated
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Betyg uppdaterat';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Handle item deletion
        function handleItemDeletion(payload) {
            console.log('Item deletion update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId } = payload.payload;
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                // Remove the item from DOM
                item.remove();
                
                // Show a subtle notification that content was updated
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Objekt borttaget';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Broadcast editing status
        function broadcastEditingStatus(cell, isEditing) {
            // Find item and get its data attributes
            const item = cell.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Include the new text when stopping editing
            const newText = isEditing ? undefined : cell.textContent;
            
            // Broadcast editing status
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'editing',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    isEditing,
                    newText
                }
            });
        }
        
        // Apply editing indicators for cells being edited by others
        function applyEditingIndicators() {
            // Clear all existing indicators first
            document.querySelectorAll('.cell-editing-other').forEach(cell => {
                cell.classList.remove('cell-editing-other');
                cell.setAttribute('contenteditable', 'false');
                
                // Add click handler to make it editable again when clicked
                cell.addEventListener('click', function(e) {
                    // Prevent editing if cell is being edited by another user
                    if (cell.classList.contains('cell-editing-other')) {
                        e.preventDefault();
                        return;
                    }
                    
                    if (cell.getAttribute('contenteditable') === 'false') {
                        cell.setAttribute('contenteditable', 'true');
                        cell.focus();
                    }
                });
            });
            
            // Apply indicators for cells being edited by others
            cellsBeingEditedByOthers.forEach((userId, cellKey) => {
                const [entityId, riskLevel, itemId] = cellKey.split('-');
                
                const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
                if (item) {
                    const textCell = item.querySelector('.item-text');
                    textCell.classList.add('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Prevent editing
                }
            });
        }

        // Generate UUID for session
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Function to add new item
        function addNewItem(button, entity, riskLevel) {
            const column = button.closest('.risk-column');
            const container = column.querySelector('.items-container');
            
            // Generate a unique ID for this item
            const itemId = generateUUID();
            
            // Create new item
            const item = document.createElement('div');
            item.className = 'item';
            item.setAttribute('draggable', 'false'); // Initially not draggable, only becomes draggable when hovering over drag handle
            item.setAttribute('data-entity', entity);
            item.setAttribute('data-risk', riskLevel);
            item.setAttribute('data-item-id', itemId);
            item.setAttribute('data-category', currentCategory); // Set the current category
            item.innerHTML = `
                <i class="bi bi-grip-vertical drag-handle" title="Dra f√∂r att √§ndra ordning"></i>
                <div class="item-text" contenteditable="true" data-placeholder="Skriv text h√§r" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)"></div>
                <div class="item-rating" onclick="showRatingSelector(this)"></div>
                <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
            `;
            
            // Add to container
            container.insertBefore(item, container.firstChild);
            
            // Focus on the text element
            const textElement = item.querySelector('.item-text');
            
            // Auto-fill with last copied text if available
            if (window.lastCopiedText) {
                textElement.textContent = window.lastCopiedText;
                
                // Clear the last copied text so it's only used once
                window.lastCopiedText = "";
                
                // Save the changes
                setTimeout(() => {
                    handleCellChange(textElement);
                }, 100);
                
                // Show notification
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                if (autoSaveIndicator) {
                    autoSaveIndicator.innerHTML = 'Intervention tillagd';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            } else {
                // Focus the element if there's no text to auto-fill
                textElement.focus();
            }
            
            // Add click handler to make text editable when clicked
            textElement.addEventListener('blur', function() {
                // After the initial edit, set contenteditable to false
                textElement.setAttribute('contenteditable', 'false');
                
                // Add click handler to make it editable again when clicked
                textElement.addEventListener('click', function(e) {
                    // Prevent editing if cell is being edited by another user
                    if (textElement.classList.contains('cell-editing-other')) {
                        e.preventDefault();
                        return;
                    }
                    
                    if (textElement.getAttribute('contenteditable') === 'false') {
                        textElement.setAttribute('contenteditable', 'true');
                        textElement.focus();
                    }
                });
            });
            
            // Add drag and drop event listeners
            initializeDragForItem(item);
            
            // Broadcast the new item to other users
            broadcastNewItem(entity, riskLevel, itemId);
            
            // Trigger auto-save
            triggerAutoSave();
        }

        // Broadcast new item
        function broadcastNewItem(entity, riskLevel, itemId) {
            // Get the position of the new item (should be 0 for top position)
            const position = 0; // New items are added at the top by default
            
            // Broadcast new item creation
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'new_item',
                payload: {
                    userId: sessionUserId,
                    entityId: entity,
                    riskLevel: riskLevel,
                    itemId: itemId,
                    position: position,
                    category: currentCategory // Add category to payload
                }
            });
        }

        // Function to handle cell focus
        function handleCellFocus(cell) {
            // Mark this cell as being edited
            currentlyEditingCell = cell;
            cell.classList.add('cell-editing');
            
            // Broadcast editing status
            broadcastEditingStatus(cell, true);
        }
        
        // Function to handle cell changes
        function handleCellChange(cell) {
            // Get the new text content
            const newText = cell.textContent.trim();
            
            // Remove editing indicator
            cell.classList.remove('cell-editing');
            
            // Broadcast that we stopped editing, including the new text
            broadcastEditingStatus(cell, false);
            
            // Clear currently editing cell if it's this one
            if (currentlyEditingCell === cell) {
                currentlyEditingCell = null;
                
                // Show rating selector automatically after editing
                const item = cell.closest('.item');
                const ratingCell = item.querySelector('.item-rating');
                showRatingSelector(ratingCell);
            }
            
            // Trigger auto-save
            triggerAutoSave();
        }

        // Function to show rating selector
        function showRatingSelector(cell) {
            // Store reference to current cell
            currentRatingCell = cell;
            
            // Get rating selector
            const selector = document.getElementById('rating-selector');
            
            // Position selector near the cell
            const rect = cell.getBoundingClientRect();
            selector.style.top = (rect.bottom + window.scrollY) + 'px';
            selector.style.left = rect.left + 'px';
            
            // Show selector
            selector.style.display = 'block';
            
            // Highlight the first option by default
            const options = selector.querySelectorAll('.rating-option');
            if (options.length > 0) {
                options.forEach(opt => opt.classList.remove('highlighted'));
                options[0].classList.add('highlighted');
                
                // Set focus to the selector for keyboard navigation
                selector.setAttribute('tabindex', '-1');
                selector.focus();
            }
            
            // Add event listener to close selector when clicking outside
            document.addEventListener('click', closeRatingSelectorOutside);
            
            // Add keyboard event listener for rating selector navigation
            document.addEventListener('keydown', handleRatingSelectorKeyboard);
        }
        
        // Function to handle keyboard navigation in rating selector
        function handleRatingSelectorKeyboard(e) {
            const selector = document.getElementById('rating-selector');
            
            // Only handle if selector is visible
            if (selector.style.display !== 'block') {
                document.removeEventListener('keydown', handleRatingSelectorKeyboard);
                return;
            }
            
            const options = selector.querySelectorAll('.rating-option');
            const highlightedOption = selector.querySelector('.rating-option.highlighted');
            let currentIndex = -1;
            
            // Find current highlighted index
            if (highlightedOption) {
                currentIndex = Array.from(options).indexOf(highlightedOption);
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    // Move to next option
                    if (currentIndex < options.length - 1) {
                        options.forEach(opt => opt.classList.remove('highlighted'));
                        options[currentIndex + 1].classList.add('highlighted');
                        options[currentIndex + 1].scrollIntoView({ block: 'nearest' });
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    // Move to previous option
                    if (currentIndex > 0) {
                        options.forEach(opt => opt.classList.remove('highlighted'));
                        options[currentIndex - 1].classList.add('highlighted');
                        options[currentIndex - 1].scrollIntoView({ block: 'nearest' });
                    }
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    // Select highlighted option
                    if (highlightedOption) {
                        highlightedOption.click();
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    // Close selector
                    selector.style.display = 'none';
                    document.removeEventListener('click', closeRatingSelectorOutside);
                    document.removeEventListener('keydown', handleRatingSelectorKeyboard);
                    break;
                    
                case 'Tab':
                    e.preventDefault();
                    // Move to next option or close if at last option
                    if (currentIndex < options.length - 1) {
                        options.forEach(opt => opt.classList.remove('highlighted'));
                        options[currentIndex + 1].classList.add('highlighted');
                        options[currentIndex + 1].scrollIntoView({ block: 'nearest' });
                    } else {
                        // At last option, close and move to next element
                        selector.style.display = 'none';
                        document.removeEventListener('click', closeRatingSelectorOutside);
                        document.removeEventListener('keydown', handleRatingSelectorKeyboard);
                    }
                    break;
            }
        }

        // Function to close rating selector when clicking outside
        function closeRatingSelectorOutside(event) {
            const selector = document.getElementById('rating-selector');
            
            // Check if click is outside the selector and not on a rating cell
            if (!selector.contains(event.target) && 
                !event.target.classList.contains('item-rating')) {
                selector.style.display = 'none';
                document.removeEventListener('click', closeRatingSelectorOutside);
                document.removeEventListener('keydown', handleRatingSelectorKeyboard);
            }
        }
        
        // Function to select a rating
        function selectRating(rating) {
            if (currentRatingCell) {
                currentRatingCell.textContent = rating;
                
                // Hide selector
                document.getElementById('rating-selector').style.display = 'none';
                document.removeEventListener('click', closeRatingSelectorOutside);
                document.removeEventListener('keydown', handleRatingSelectorKeyboard);
                
                // Broadcast the rating change to other users
                broadcastRatingChange(currentRatingCell, rating);
                
                // Trigger auto-save
                triggerAutoSave();
            }
        }
        
        // Broadcast rating change
        function broadcastRatingChange(cell, rating) {
            // Find item and get its data attributes
            const item = cell.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Broadcast rating change
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'rating_change',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    rating
                }
            });
        }
        
        // Variables for delete confirmation
        let itemToDelete = null;
        
        // Function to show delete confirmation modal
        function showDeleteModal(button) {
            itemToDelete = button;
            document.getElementById('delete-confirm-modal').style.display = 'flex';
        }
        
        // Function to close delete confirmation modal
        function closeDeleteModal() {
            document.getElementById('delete-confirm-modal').style.display = 'none';
            itemToDelete = null;
        }
        
        // Function to confirm delete
        function confirmDelete() {
            if (itemToDelete) {
                const item = itemToDelete.closest('.item');
                const entityId = item.getAttribute('data-entity');
                const riskLevel = item.getAttribute('data-risk');
                const itemId = item.getAttribute('data-item-id');
                
                // Remove the item from DOM
                item.remove();
                
                // Broadcast the deletion to other users
                broadcastItemDeletion(entityId, riskLevel, itemId);
                
                // Trigger auto-save
                triggerAutoSave();
                
                // Close the modal
                closeDeleteModal();
            }
        }
        
        // Function to delete item
        function deleteItem(button) {
            showDeleteModal(button);
        }
        
        // Broadcast item deletion
        function broadcastItemDeletion(entityId, riskLevel, itemId) {
            // Broadcast deletion
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'item_deletion',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId
                }
            });
        }
        
        // Function to trigger auto-save with debounce
        function triggerAutoSave() {
            // Show saving indicator
            const autoSaveIndicator = document.getElementById('auto-save-indicator');
            autoSaveIndicator.innerHTML = '<span class="saving">Sparar...</span>';
            
            // Clear previous timeout
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            // Set new timeout
            saveTimeout = setTimeout(() => {
                saveDataToSupabase();
            }, saveDelay);
        }
        
        // Function to show status message
        function showStatusMessage(message, isSuccess) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = message;
            statusMessage.className = 'status-message';
            
            if (isSuccess) {
                statusMessage.classList.add('success-message');
            } else {
                statusMessage.classList.add('error-message');
            }
            
            statusMessage.style.display = 'block';
            
            // Hide message after 5 seconds
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }
        
        // Function to collect all items data
        function collectItemsData() {
            const items = [];
            
            // Get all entity rows
            const entityRows = document.querySelectorAll('.entity-row');
            
            entityRows.forEach(entityRow => {
                const entity = entityRow.querySelector('.entity-title').textContent;
                
                // Get all risk columns in this entity row
                const riskColumns = entityRow.querySelectorAll('.risk-column');
                
                riskColumns.forEach(column => {
                    // Determine risk level
                    let riskLevel = 'Unknown';
                    if (column.classList.contains('no-risk')) riskLevel = 'No';
                    if (column.classList.contains('at-risk')) riskLevel = 'At';
                    if (column.classList.contains('high-risk')) riskLevel = 'High';
                    
                    // Get all items in this column
                    const itemElements = column.querySelectorAll('.item');
                    
                    // Update position attributes in DOM to match actual positions
                    Array.from(itemElements).forEach((item, index) => {
                        item.setAttribute('data-position', index.toString());
                    });
                    
                    itemElements.forEach((item, index) => {
                        const text = item.querySelector('.item-text').textContent.trim();
                        const rating = item.querySelector('.item-rating').textContent.trim();
                        
                        if (text) {
                            // Create item data with exact position
                            const itemData = {
                                text: text,
                                entity: entity,
                                risk_level: riskLevel,
                                category: currentCategory,
                                rating: rating,
                                position: index,
                                id: item.getAttribute('data-item-id')
                            };
                            
                            items.push(itemData);
                            
                            // Log each item's position for debugging
                            console.log(`Saving ${entity} - ${riskLevel} item at position ${index}: ${text.substring(0, 20)}...`);
                        }
                    });
                });
            });
            
            return items;
        }
        
        // Function to save data to Supabase
        async function saveDataToSupabase() {
            try {
                // Set flag that we're saving
                isCurrentlySaving = true;
                
                const itemsData = collectItemsData();
                
                // Use fetch to save data to the server
                const response = await fetch('/save_items', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                    body: JSON.stringify({
                        category: currentCategory,
                        items: itemsData
                    })
                });
                
                const data = await response.json();
                
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Error saving data');
                }
                
                // Update auto-save indicator
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Sparad';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
                
                // Reset saving flag
                isCurrentlySaving = false;
                
            } catch (error) {
                console.error('Error saving data:', error);
                
                // Update auto-save indicator
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Fel vid sparande';
                
                // Show error message
                showStatusMessage('Ett fel uppstod n√§r data skulle sparas: ' + error.message, false);
                
                // Reset saving flag
                isCurrentlySaving = false;
            }
        }
        
        // Initialize drag and drop for an item
        function initializeDragForItem(item) {
            // Remove any existing event listeners first
            item.removeEventListener('dragstart', handleDragStart);
            item.removeEventListener('dragend', handleDragEnd);
            item.removeEventListener('dragover', handleDragOver);
            item.removeEventListener('drop', handleDrop);
            
            // Add event listeners
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('drop', handleDrop);
            
            // Ensure the drag handle is properly interactive
            const dragHandle = item.querySelector('.drag-handle');
            if (dragHandle) {
                dragHandle.addEventListener('mouseenter', function() {
                    item.setAttribute('draggable', 'true');
                    dragHandle.style.cursor = 'grab';
                });
                
                dragHandle.addEventListener('mouseleave', function() {
                    // Only set draggable to false if we're not currently dragging
                    if (!item.classList.contains('dragging')) {
                        item.setAttribute('draggable', 'false');
                    }
                });
                
                dragHandle.addEventListener('mousedown', function(e) {
                    // Store a reference to the item being dragged
                    draggedItem = item;
                    dragHandle.style.cursor = 'grabbing';
                });
                
                dragHandle.addEventListener('mouseup', function() {
                    dragHandle.style.cursor = 'grab';
                });
            }
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            // Store a reference to the item being dragged
            draggedItem = this;
            isDragging = true;
            
            // Add a class to show it's being dragged
            this.classList.add('dragging');
            
            // Set the data being dragged
            // Get only the text content, excluding the rating
            const textOnly = this.querySelector('.item-text') ? 
                this.querySelector('.item-text').textContent : 
                this.textContent.replace('Kopiera', '').trim();
            
            e.dataTransfer.setData('text/plain', textOnly);
            
            // Set how it looks when dragged
            if (e.dataTransfer.setDragImage) {
                const dragIcon = document.createElement('div');
                dragIcon.textContent = textOnly;
                dragIcon.style.backgroundColor = '#5D6D7E';
                dragIcon.style.color = 'white';
                dragIcon.style.padding = '10px';
                dragIcon.style.borderRadius = '6px';
                dragIcon.style.position = 'absolute';
                dragIcon.style.top = '-1000px';
                document.body.appendChild(dragIcon);
                
                e.dataTransfer.setDragImage(dragIcon, 0, 0);
                
                // Remove the temporary element after a bit
                setTimeout(() => {
                    document.body.removeChild(dragIcon);
                }, 0);
            }
            
            // Listen for drag end
            this.addEventListener('dragend', function() {
                isDragging = false;
                
                this.classList.remove('dragging');
                
                // Reset draggable attribute after dragging
                setTimeout(() => {
                    this.setAttribute('draggable', 'false');
                }, 100);
                
                // Remove drag-over class from all items
                const items = document.querySelectorAll('.item');
                items.forEach(item => item.classList.remove('drag-over'));
                
                // Remove drag-over class from all containers
                const containers = document.querySelectorAll('.items-container');
                containers.forEach(container => container.classList.remove('container-drag-over'));
                
                // Also remove drag-over class from all risk cells
                const riskCells = document.querySelectorAll('.no-risk, .at-risk, .high-risk');
                riskCells.forEach(cell => {
                    cell.classList.remove('drag-over');
                });
                
                draggedItem = null;
            }, { once: true });
        }

        function handleDragEnd(e) {
            isDragging = false;
            
            this.classList.remove('dragging');
            
            // Reset draggable attribute after dragging
            setTimeout(() => {
                this.setAttribute('draggable', 'false');
            }, 100);
            
            // Remove drag-over class from all items
            const items = document.querySelectorAll('.item');
            items.forEach(item => item.classList.remove('drag-over'));
            
            // Remove drag-over class from all containers
            const containers = document.querySelectorAll('.items-container');
            containers.forEach(container => container.classList.remove('container-drag-over'));
            
            // Also remove drag-over class from all risk cells
            const riskCells = document.querySelectorAll('.no-risk, .at-risk, .high-risk');
            riskCells.forEach(cell => {
                cell.classList.remove('drag-over');
            });
            
            draggedItem = null;
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            
            // Don't allow dragging if any cell is being edited
            if (currentlyEditingCell) {
                return;
            }
            
            // Handle drag over items
            const item = e.target.closest('.item');
            if (item && item !== draggedItem) {
                // Remove drag-over class from all items
                const items = document.querySelectorAll('.item');
                items.forEach(i => i.classList.remove('drag-over'));
                
                // Get mouse position relative to the item
                const rect = item.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + (rect.height / 2);
                
                // Add drag-over class to the appropriate item
                if (mouseY < threshold) {
                    item.classList.add('drag-over');
                } else {
                    // If mouse is in bottom half, add class to next item if it exists
                    const nextItem = item.nextElementSibling;
                    if (nextItem) {
                        nextItem.classList.add('drag-over');
                    } else {
                        // If there's no next item, add class to current item
                        item.classList.add('drag-over');
                    }
                }
            }
            // Handle drag over empty containers
            else {
                const container = e.target.closest('.items-container');
                if (container) {
                    // Remove drag-over class from all containers
                    const containers = document.querySelectorAll('.items-container');
                    containers.forEach(c => c.classList.remove('container-drag-over'));
                    
                    // Add drag-over class to this container
                    container.classList.add('container-drag-over');
                }
            }
            
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            // Don't allow dropping if any cell is being edited
            if (currentlyEditingCell) {
                return;
            }
            
            // Make sure we have a valid dragged item
            if (!draggedItem) {
                console.log('No dragged item found');
                return false;
            }
            
            // Get original position and risk level before moving
            const originalRiskLevel = draggedItem.getAttribute('data-risk');
            const entityId = draggedItem.getAttribute('data-entity');
            const originalContainer = draggedItem.parentNode;
            // Get original position before any DOM changes
            const originalPosition = Array.from(originalContainer.children).indexOf(draggedItem);
            
            console.log(`Original position: ${originalPosition}, Risk level: ${originalRiskLevel}, Entity: ${entityId}`);
            
            // Handle drop on items
            const targetItem = e.target.closest('.item');
            if (targetItem && targetItem !== draggedItem) {
                // Get mouse position relative to the item
                const rect = targetItem.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + (rect.height / 2);
                
                // Remove drag-over class
                targetItem.classList.remove('drag-over');
                
                // Get the container
                const container = targetItem.parentNode;
                
                // Store current children before any DOM changes
                const oldChildren = Array.from(container.children);
                const targetIndex = oldChildren.indexOf(targetItem);
                
                // Store if we're in the same container (important for reordering logic)
                const sameContainer = (container === originalContainer);
                console.log(`Same container: ${sameContainer}, Target index: ${targetIndex}`);
                
                // Temporarily detach the dragged item to avoid position calculation issues
                draggedItem.remove();
                
                // Insert the item based on mouse position
                let newPosition;
                if (mouseY < threshold) {
                    // Insert before target item
                    container.insertBefore(draggedItem, targetItem);
                    newPosition = Array.from(container.children).indexOf(draggedItem);
                } else {
                    // Insert after target item
                    container.insertBefore(draggedItem, targetItem.nextSibling);
                    newPosition = Array.from(container.children).indexOf(draggedItem);
                }
                
                console.log(`New position: ${newPosition}`);
                
                // Get new risk level after moving
                const riskColumn = container.closest('.risk-column');
                let newRiskLevel = originalRiskLevel;
                if (riskColumn.classList.contains('no-risk')) newRiskLevel = 'No';
                if (riskColumn.classList.contains('at-risk')) newRiskLevel = 'At';
                if (riskColumn.classList.contains('high-risk')) newRiskLevel = 'High';
                
                // Update the risk level attribute if it changed
                if (newRiskLevel !== originalRiskLevel) {
                    console.log(`Risk level changed from ${originalRiskLevel} to ${newRiskLevel}`);
                    draggedItem.setAttribute('data-risk', newRiskLevel);
                    
                    // Broadcast the move to other users, including the position
                    broadcastItemMove(
                        entityId,
                        originalRiskLevel,
                        newRiskLevel,
                        draggedItem.getAttribute('data-item-id')
                    );
                } else {
                    // Store position in the item
                    draggedItem.setAttribute('data-position', newPosition.toString());
                    
                    // Broadcast position change within the same risk level
                    broadcastItemReorder(
                        entityId,
                        newRiskLevel,
                        draggedItem.getAttribute('data-item-id'),
                        newPosition
                    );
                }
                
                // Trigger auto-save to save the new order
                triggerAutoSave();
            }
            // Handle drop on empty containers
            else {
                const container = e.target.closest('.items-container');
                if (container) {
                    console.log('Dropping on container:', container);
                    
                    // Remove container drag-over class
                    container.classList.remove('container-drag-over');
                    
                    // Get new risk level
                    const riskColumn = container.closest('.risk-column');
                    let newRiskLevel = originalRiskLevel;
                    if (riskColumn.classList.contains('no-risk')) newRiskLevel = 'No';
                    if (riskColumn.classList.contains('at-risk')) newRiskLevel = 'At';
                    if (riskColumn.classList.contains('high-risk')) newRiskLevel = 'High';
                    console.log('New risk level:', newRiskLevel);
                    
                    // Store if we're in the same container (important for reordering logic)
                    const sameContainer = (container === originalContainer);
                    console.log(`Same container: ${sameContainer}`);
                    
                    // Temporarily detach the dragged item to avoid position calculation issues
                    draggedItem.remove();
                    
                    // If the drop is near the top of the container, insert at the beginning
                    const containerRect = container.getBoundingClientRect();
                    const mouseY = e.clientY;
                    const topThreshold = containerRect.top + 20; // 20px from top
                    
                    let newPosition;
                    if (mouseY < topThreshold && container.children.length > 0) {
                        // Drop at top of container
                        container.insertBefore(draggedItem, container.firstChild);
                    } else {
                        // Drop at end of container
                        container.appendChild(draggedItem);
                    }
                    
                    // Calculate the new position
                    newPosition = Array.from(container.children).indexOf(draggedItem);
                    console.log(`New position: ${newPosition}`);
                    
                    // Update the risk level attribute if it changed
                    if (newRiskLevel !== originalRiskLevel) {
                        console.log('Risk level changed, updating attribute and broadcasting');
                        draggedItem.setAttribute('data-risk', newRiskLevel);
                        
                        // Broadcast the move to other users
                        broadcastItemMove(
                            entityId,
                            originalRiskLevel,
                            newRiskLevel,
                            draggedItem.getAttribute('data-item-id')
                        );
                    } else {
                        // Store position in the item
                        draggedItem.setAttribute('data-position', newPosition.toString());
                        
                        // Broadcast position change
                        broadcastItemReorder(
                            entityId,
                            newRiskLevel,
                            draggedItem.getAttribute('data-item-id'),
                            newPosition
                        );
                    }
                    
                    // Trigger auto-save to save the new order and risk level
                    triggerAutoSave();
                }
            }
            
            return false;
        }

        // Broadcast item move between risk levels
        function broadcastItemMove(entityId, originalRiskLevel, newRiskLevel, itemId) {
            console.log('Broadcasting item move:', { entityId, originalRiskLevel, newRiskLevel, itemId });
            
            // Get the position within the new container
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${newRiskLevel}"][data-item-id="${itemId}"]`);
            const container = item.parentNode;
            
            // Calculate exact position
            const newPosition = Array.from(container.children).indexOf(item);
            console.log('Item moved to position:', newPosition);
            
            // Store the position in a data attribute for verification
            item.setAttribute('data-position', newPosition.toString());
            
            // Broadcast move with exact position information
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'item_move',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    originalRiskLevel,
                    newRiskLevel,
                    itemId,
                    newPosition
                }
            }).then(() => {
                console.log('Item move broadcast sent successfully with position:', newPosition);
            }).catch(error => {
                console.error('Error broadcasting item move:', error);
            });
        }

        // Handle item move between risk levels
        function handleItemMove(payload) {
            console.log('Item move update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, originalRiskLevel, newRiskLevel, itemId, newPosition } = payload.payload;
            console.log(`Moving item to position ${newPosition} in ${newRiskLevel} risk level`);
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${originalRiskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                // Find the entity row
                const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                    .find(row => row.querySelector('.entity-title').textContent === entityId);
                
                if (entityRow) {
                    // Find the target risk column
                    const riskColumn = entityRow.querySelector(
                        newRiskLevel === 'No' ? '.no-risk' :
                        newRiskLevel === 'At' ? '.at-risk' :
                        '.high-risk'
                    );
                    
                    if (riskColumn) {
                        // Find the target container
                        const targetContainer = riskColumn.querySelector('.items-container');
                        
                        // Update the risk level attribute
                        item.setAttribute('data-entity', entityId); // Ensure entity is correct
                        item.setAttribute('data-risk', newRiskLevel); // Update risk level
                        
                        // Add a subtle animation effect
                        item.style.transition = 'all 0.5s ease';
                        item.style.backgroundColor = 'rgba(13, 110, 253, 0.1)';
                        
                        // Remove the item from its current container
                        item.remove();
                        
                        // Get the existing items in the target container
                        const targetItems = Array.from(targetContainer.children);
                        
                        // Insert the item at the specified position - handle edge cases carefully
                        if (newPosition !== undefined) {
                            if (newPosition === 0) {
                                // Special case for position 0 (beginning of container)
                                targetContainer.insertBefore(item, targetContainer.firstChild);
                            } else if (newPosition < targetItems.length) {
                                // Insert at the specified position
                                targetContainer.insertBefore(item, targetItems[newPosition]);
                            } else {
                                // If position is at or beyond the end, append to the end
                                targetContainer.appendChild(item);
                            }
                            
                            // Store the position in a data attribute for verification
                            item.setAttribute('data-position', newPosition.toString());
                            
                            console.log(`Item moved to position ${newPosition} in container`);
                        } else {
                            // Fallback: append to the end if no position specified
                            targetContainer.appendChild(item);
                            console.log('No position specified, appended to end');
                        }
                        
                        // Return to normal appearance after animation
                        setTimeout(() => {
                            item.style.backgroundColor = '';
                            
                            // Reset transition after animation completes
                            setTimeout(() => {
                                item.style.transition = '';
                            }, 500);
                        }, 500);
                        
                        // Verify final position
                        const finalPosition = Array.from(targetContainer.children).indexOf(item);
                        console.log(`Final position verification: ${finalPosition} (expected ${newPosition})`);
                        
                        // Show a subtle notification that content was updated
                        const autoSaveIndicator = document.getElementById('auto-save-indicator');
                        autoSaveIndicator.innerHTML = 'Objekt flyttat';
                        setTimeout(() => {
                            autoSaveIndicator.innerHTML = '';
                        }, 2000);
                    } else {
                        console.error('Target risk column not found for level:', newRiskLevel);
                    }
                } else {
                    console.error('Entity row not found for entity:', entityId);
                }
            } else {
                console.error('Item not found for move:', { entityId, originalRiskLevel, itemId });
            }
        }

        // Broadcast item reorder within same risk level
        function broadcastItemReorder(entityId, riskLevel, itemId, newPosition) {
            console.log(`Broadcasting item reorder to position ${newPosition}`);
            
            // Verify position with a direct DOM check
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (!item) {
                console.error(`Item not found for reorder: ${entityId}, ${riskLevel}, ${itemId}`);
                return;
            }
            
            const container = item.parentNode;
            if (!container) {
                console.error(`Container not found for item: ${itemId}`);
                return;
            }
            
            // Force DOM position check - this is critical for accurate synchronization
            const actualPosition = Array.from(container.children).indexOf(item);
            
            // Store the position in a data attribute for verification
            item.setAttribute('data-position', actualPosition.toString());
            
            // Always use actual position from DOM to ensure accuracy
            if (actualPosition !== newPosition) {
                console.log(`Position correction: ${newPosition} ‚Üí ${actualPosition}`);
                newPosition = actualPosition;
            }
            
            // Log all items in container for debugging
            console.log('Current container items:');
            Array.from(container.children).forEach((child, idx) => {
                console.log(`  [${idx}] ${child.getAttribute('data-item-id')} - ${child.querySelector('.item-text')?.textContent?.substring(0, 20) || 'no text'}`);
            });
            
            // Broadcast reorder with verified position
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'item_reorder',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    newPosition: newPosition, // Use verified position
                    timestamp: Date.now() // Add timestamp to help with ordering of events
                }
            }).then(() => {
                console.log('Item reorder broadcast sent successfully with position:', newPosition);
            }).catch(error => {
                console.error('Error broadcasting item reorder:', error);
            });
        }

        // Initialize drag and drop for all containers
        function initializeDragAndDrop() {
            // Initialize items
            const items = document.querySelectorAll('.item');
            items.forEach(item => {
                // Set draggable attribute to false initially
                item.setAttribute('draggable', 'false');
                // Initialize drag and drop for the item
                initializeDragForItem(item);
            });
            
            // Initialize containers
            const containers = document.querySelectorAll('.items-container');
            containers.forEach(container => {
                container.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    
                    // Don't allow dragging if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // Make sure the container is a valid drop target
                    // This is important for empty containers
                    if (draggedItem) {
                        // Remove drag-over class from all containers
                        const containers = document.querySelectorAll('.items-container');
                        containers.forEach(c => c.classList.remove('container-drag-over'));
                        
                        // Add drag-over class to this container
                        this.classList.add('container-drag-over');
                    }
                });
                
                container.addEventListener('drop', function(e) {
                    e.preventDefault();
                    
                    // Don't allow dropping if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // If we have a dragged item
                    if (draggedItem) {
                        console.log('Dropping directly on container:', this);
                        
                        // Remove container drag-over class
                        this.classList.remove('container-drag-over');
                        
                        // Get original position and risk level before moving
                        const originalRiskLevel = draggedItem.getAttribute('data-risk');
                        console.log('Original risk level:', originalRiskLevel);
                        
                        // Append to the container
                        this.appendChild(draggedItem);
                        
                        // Get new risk level after moving
                        const riskColumn = this.closest('.risk-column');
                        let newRiskLevel = originalRiskLevel;
                        if (riskColumn.classList.contains('no-risk')) newRiskLevel = 'No';
                        if (riskColumn.classList.contains('at-risk')) newRiskLevel = 'At';
                        if (riskColumn.classList.contains('high-risk')) newRiskLevel = 'High';
                        console.log('New risk level:', newRiskLevel);
                        
                        // Update the risk level attribute if it changed
                        if (newRiskLevel !== originalRiskLevel) {
                            console.log('Risk level changed, updating attribute and broadcasting');
                            draggedItem.setAttribute('data-risk', newRiskLevel);
                            
                            // Broadcast the move to other users
                            broadcastItemMove(
                                draggedItem.getAttribute('data-entity'),
                                originalRiskLevel,
                                newRiskLevel,
                                draggedItem.getAttribute('data-item-id')
                            );
                    } else {
                            console.log('Risk level unchanged, broadcasting reorder');
                            // Broadcast position change
                            broadcastItemReorder(
                                draggedItem.getAttribute('data-entity'),
                                newRiskLevel,
                                draggedItem.getAttribute('data-item-id'),
                                Array.from(this.children).indexOf(draggedItem)
                            );
                        }
                        
                        // Trigger auto-save to save the new order and risk level
                        triggerAutoSave();
                    }
                });
            });
            
            // Also initialize risk columns to handle drops directly on them
            const riskColumns = document.querySelectorAll('.risk-column');
            riskColumns.forEach(column => {
                column.addEventListener('dragover', function(e) {
                    // Don't allow dragging if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // Only handle if we're not already over an items-container
                    if (!e.target.closest('.items-container') && draggedItem) {
                        e.preventDefault();
                        
                        // Find the items container within this risk column
                        const container = this.querySelector('.items-container');
                        if (container) {
                            // Remove drag-over class from all containers
                            const containers = document.querySelectorAll('.items-container');
                            containers.forEach(c => c.classList.remove('container-drag-over'));
                            
                            // Add drag-over class to this container
                            container.classList.add('container-drag-over');
                        }
                    }
                });
                
                column.addEventListener('drop', function(e) {
                    // Don't allow dropping if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // Only handle if we're not already over an items-container
                    if (!e.target.closest('.items-container') && draggedItem) {
                        e.preventDefault();
                        
                        console.log('Dropping on risk column:', this);
                        
                        // Find the items container within this risk column
                        const container = this.querySelector('.items-container');
                        if (container) {
                            // Remove container drag-over class
                            container.classList.remove('container-drag-over');
                            
                            // Get original position and risk level before moving
                            const originalRiskLevel = draggedItem.getAttribute('data-risk');
                            console.log('Original risk level:', originalRiskLevel);
                            
                            // Append to the container
                            container.appendChild(draggedItem);
                            
                            // Get new risk level after moving
                            let newRiskLevel = originalRiskLevel;
                            if (this.classList.contains('no-risk')) newRiskLevel = 'No';
                            if (this.classList.contains('at-risk')) newRiskLevel = 'At';
                            if (this.classList.contains('high-risk')) newRiskLevel = 'High';
                            console.log('New risk level:', newRiskLevel);
                            
                            // Update the risk level attribute if it changed
                            if (newRiskLevel !== originalRiskLevel) {
                                console.log('Risk level changed, updating attribute and broadcasting');
                                draggedItem.setAttribute('data-risk', newRiskLevel);
                                
                                // Broadcast the move to other users
                                broadcastItemMove(
                                    draggedItem.getAttribute('data-entity'),
                                    originalRiskLevel,
                                    newRiskLevel,
                                    draggedItem.getAttribute('data-item-id')
                                );
                            } else {
                                console.log('Risk level unchanged, broadcasting reorder');
                                // Broadcast position change
                                broadcastItemReorder(
                                    draggedItem.getAttribute('data-entity'),
                                    newRiskLevel,
                                    draggedItem.getAttribute('data-item-id'),
                                    Array.from(container.children).indexOf(draggedItem)
                                );
                            }
                            
                            // Trigger auto-save to save the new order and risk level
                            triggerAutoSave();
                        }
                    }
                });
            });
        }

        // Load saved items when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Document ready, initializing app...');
            
            // Load saved items when page loads
            const savedItems = JSON.parse('{{ saved_items_json | safe }}' || '[]');
            
            // Sort items by position before loading
            savedItems.sort((a, b) => {
                // First group by entity and risk_level
                if (a.entity !== b.entity) return a.entity.localeCompare(b.entity);
                if (a.risk_level !== b.risk_level) return a.risk_level.localeCompare(b.risk_level);
                // Then sort by position
                return a.position - b.position;
            });
            
            savedItems.forEach(item => {
                if (item.category === currentCategory) {
                    // Find the correct container
                    const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
                    
                    if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                        
                        if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                            const itemElement = document.createElement('div');
                            itemElement.className = 'item';
                            itemElement.setAttribute('draggable', 'false');
                            itemElement.setAttribute('data-entity', item.entity);
                            itemElement.setAttribute('data-risk', item.risk_level);
                            itemElement.setAttribute('data-item-id', item.id || generateUUID());
                            itemElement.setAttribute('data-position', item.position.toString());
                            itemElement.setAttribute('data-category', item.category);
                            
                            // Use empty string if rating is null, undefined, or empty
                            const ratingValue = item.rating || '';
                            
                            itemElement.innerHTML = `
                                <i class="bi bi-grip-vertical drag-handle" title="Dra f√∂r att √§ndra ordning"></i>
                                <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text}</div>
                                <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                                <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                            `;
                            
                            // Insert at the correct position
                            if (item.position === 0) {
                                // Special case for position 0
                                container.insertBefore(itemElement, container.firstChild);
                            } else if (container.children.length > item.position) {
                                container.insertBefore(itemElement, container.children[item.position]);
                            } else {
                                container.appendChild(itemElement);
                            }
                            
                            // Add click handler to make text editable when clicked
                            const textElement = itemElement.querySelector('.item-text');
                            textElement.addEventListener('click', function(e) {
                                // Prevent editing if cell is being edited by another user
                                if (textElement.classList.contains('cell-editing-other')) {
                                    e.preventDefault();
                                    return;
                                }
                                
                                if (textElement.getAttribute('contenteditable') === 'false') {
                                    textElement.setAttribute('contenteditable', 'true');
                                    textElement.focus();
                                }
                            });
                            
                            // Initialize drag and drop for this item
                            initializeDragForItem(itemElement);
                        }
                    }
                }
            });
            
            // Setup realtime connections
            const channels = setupRealtimeSubscription();
            
            // Clean up subscription when page unloads
            window.addEventListener('beforeunload', () => {
                console.log('Cleaning up subscription...');
                
                // Broadcast that we stopped editing any cell
                if (currentlyEditingCell) {
                    broadcastEditingStatus(currentlyEditingCell, false);
                }
                
                channels.forEach(channel => {
                    supabaseClient.removeChannel(channel);
                });
            });
            
            // Initialize drag and drop
            initializeDragAndDrop();
            
            // Fix any position inconsistencies on initial load
            setTimeout(() => {
                // Update all position attributes to match actual DOM positions
                document.querySelectorAll('.items-container').forEach(container => {
                    Array.from(container.children).forEach((item, index) => {
                        item.setAttribute('data-position', index.toString());
                    });
                });
                
                console.log('Initial position synchronization complete');
            }, 1000);
            
            // Setup keyboard shortcuts
            setupKeyboardShortcuts();
            
            // Check welcome status
            if (!localStorage.getItem('welcomeShown')) {
                setTimeout(showWelcomeModal, 500);
            } else {
                if (localStorage.getItem('dragHintShown') === 'true') {
                    // Show help button immediately
                    showHelpButton();
                } else {
                    // Show drag hint after a short delay
                    setTimeout(showDragHint, 2000);
                }
            }
        });
        
        // Function to show welcome modal
        function showWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            modal.style.display = 'flex';
        }
        
        // Function to close welcome modal
        function closeWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            modal.style.display = 'none';
            
            // Mark as shown
            localStorage.setItem('welcomeShown', 'true');
            
            // Show drag hint after closing welcome modal
            setTimeout(showDragHint, 1000);
        }
        
        // Function to update welcome preference
        function updateWelcomePreference() {
            const checkbox = document.getElementById('dont-show-welcome');
            if (checkbox.checked) {
                localStorage.setItem('welcomeShown', 'true');
                } else {
                localStorage.removeItem('welcomeShown');
            }
        }
        
        // Tips for the drag hint popup
        // ... existing code ...
// ... existing code ...
const tips = [
    "Klicka p√• texten f√∂r att redigera, tryck Enter n√§r du √§r klar.",
    "Klicka p√• bed√∂mningsdelen f√∂r att s√§tta ett betyg.",
    "Tryck p√• plus-knappen f√∂r att l√§gga till ett nytt objekt.",
    "Du kan dra i cellen f√∂r att √§ndra ordning p√• objekten i riskkorten.",
    "Alla √§ndringar sparas automatiskt.",
    "Klicka p√• interventionsknappen <i class='bi bi-clipboard-check'></i> f√∂r att f√• f√∂rslag p√• √•tg√§rder och insatser.",
    "Interventionsf√∂rslagen √§r kategoriserade f√∂r enklare navigering.",
    "Du kan s√∂ka bland interventionsf√∂rslagen med s√∂kfunktionen.",
    "Du kan l√§gga till egna interventionsf√∂rslag genom att skriva in dem i rutan och trycka p√• plusknappen.",
    "Klicka p√• cellen f√∂r att kopiera interventionsf√∂rslaget till urklipp. De klistras in automatiskt n√§r du trycker p√• plusknappen i ett riskkort.",
    "Dina egna interventionsf√∂rslag sparas och finns tillg√§ngliga n√§sta g√•ng du anv√§nder verktyget.",
// ... existing code ...
        ];
        
        let currentTipIndex = 0;
        
        // Function to show drag hint
        function showDragHint(forceShow = false) {
            if (forceShow || !localStorage.getItem('dragHintSeen')) {
                const dragHint = document.getElementById('drag-hint');
                dragHint.style.display = 'flex';
                
                // Set total tips counter
                document.getElementById('total-tips').textContent = tips.length;
                
                // Show first tip
                showTip(0);
                
                // Hide the help floating button
                document.getElementById('help-floating-btn').classList.remove('visible');
            }
        }
        
        // Function to show a specific tip
        function showTip(index) {
            // Ensure index is within bounds
            if (index < 0) index = tips.length - 1;
            if (index >= tips.length) index = 0;
            
            currentTipIndex = index;
            
            // Add fade out effect
            const tipText = document.getElementById('drag-hint-text');
            tipText.classList.add('fade');
            
            // Update content after short delay for transition
            setTimeout(() => {
                tipText.innerHTML = tips[index];
                document.getElementById('current-tip').textContent = index + 1;
                
                // Remove fade class to fade back in
                setTimeout(() => {
                    tipText.classList.remove('fade');
                }, 50);
            }, 200);
        }
        
        // Function to show next tip
        function nextTip() {
            showTip(currentTipIndex + 1);
        }
        
        // Function to show previous tip
        function previousTip() {
            showTip(currentTipIndex - 1);
        }
        
        // Function to close drag hint
        function closeDragHint() {
            document.getElementById('drag-hint').style.display = 'none';
            
            // Show the help button
            document.getElementById('help-floating-btn').classList.add('visible');
            
            // Mark as seen in localStorage
            localStorage.setItem('dragHintSeen', 'true');
        }
        
        // Function to show help button
        function showHelpButton() {
            const helpButton = document.getElementById('help-floating-btn');
            helpButton.classList.add('visible');
        }
        
        // Function to hide help button
        function hideHelpButton() {
            const helpButton = document.getElementById('help-floating-btn');
            helpButton.classList.remove('visible');
        }
        
        // Function to show shortcuts modal
        function showShortcutsModal() {
            const modal = document.getElementById('shortcuts-modal');
            modal.style.display = 'flex';
        }
        
        // Function to close shortcuts modal
        function closeShortcutsModal() {
            const modal = document.getElementById('shortcuts-modal');
            modal.style.display = 'none';
        }
        
        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Show shortcuts modal when '?' is pressed
            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                showShortcutsModal();
                e.preventDefault();
            }
            
            // Close modal with Escape key
            if (e.key === 'Escape' && document.getElementById('shortcuts-modal').style.display === 'flex') {
                closeShortcutsModal();
                e.preventDefault();
            }
            
            // Ctrl+S to save manually
            if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                saveDataToSupabase();
                e.preventDefault();
            }
            
            // Ctrl+N to add new item in the first column
            if (e.key === 'n' && (e.ctrlKey || e.metaKey)) {
                // Find the first add button and click it
                const firstAddButton = document.querySelector('.add-item-btn');
                if (firstAddButton) {
                    firstAddButton.click();
                }
                e.preventDefault();
            }
            
            // Delete key to remove selected item
            if (e.key === 'Delete' && currentlyEditingCell) {
                const item = currentlyEditingCell.closest('.item');
                if (item) {
                    const deleteButton = item.querySelector('.delete-btn');
                    if (deleteButton) {
                        deleteButton.click();
                    }
                }
            }
            
            // Enter key to finish editing
            if (e.key === 'Enter' && currentlyEditingCell) {
                currentlyEditingCell.blur();
                e.preventDefault();
            }
            
            // Tab key to show rating selector
            if (e.key === 'Tab' && !e.shiftKey) {
                // If we're currently editing a cell, finish editing and show rating selector
                if (currentlyEditingCell) {
                    e.preventDefault();
                    
                    // Finish editing
                    currentlyEditingCell.blur();
                    
                    // Wait a short moment for the blur event to complete
                    setTimeout(() => {
                        // Show rating selector for this item
                        const item = currentlyEditingCell.closest('.item');
                        if (item) {
                            const ratingCell = item.querySelector('.item-rating');
                            showRatingSelector(ratingCell);
                        }
                    }, 50);
                }
                // If a rating selector is already open, select the first option
                else if (document.getElementById('rating-selector').style.display === 'block') {
                    e.preventDefault();
                    
                    // Find the first rating option and click it
                    const firstOption = document.querySelector('.rating-option');
                    if (firstOption) {
                        firstOption.click();
                    }
                }
            }
        });
        
        // Close modal when clicking outside
        window.addEventListener('click', function(e) {
            const modal = document.getElementById('shortcuts-modal');
            if (e.target === modal) {
                closeShortcutsModal();
            }
        });

        // Handle new item
        function handleNewItem(payload) {
            console.log('New item update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId, position, category } = payload.payload;
            
            // Skip if category doesn't match current category
            if (category !== currentCategory) {
                console.log('Ignoring new item from different category:', category);
                return;
            }
            
            // Find the correct container
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent === entityId);
            
            if (entityRow) {
                const riskColumn = entityRow.querySelector(
                    riskLevel === 'No' ? '.no-risk' :
                    riskLevel === 'At' ? '.at-risk' :
                    '.high-risk'
                );
                
                if (riskColumn) {
                    const container = riskColumn.querySelector('.items-container');
                    
                    // Check if this item already exists (to avoid duplicates)
                    const existingItem = document.querySelector(`.item[data-item-id="${itemId}"]`);
                    if (!existingItem) {
                        // Create new item
                        const itemElement = document.createElement('div');
                        itemElement.className = 'item';
                        itemElement.setAttribute('draggable', 'false'); // Initially not draggable
                        itemElement.setAttribute('data-entity', entityId);
                        itemElement.setAttribute('data-risk', riskLevel);
                        itemElement.setAttribute('data-item-id', itemId);
                        itemElement.setAttribute('data-category', category || currentCategory); // Set category
                        
                        itemElement.innerHTML = `
                            <i class="bi bi-grip-vertical drag-handle" title="Dra f√∂r att √§ndra ordning"></i>
                            <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)"></div>
                            <div class="item-rating" onclick="showRatingSelector(this)"></div>
                            <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                        `;
                        
                        // Add to container at the specified position (or top if not specified)
                        if (position !== undefined && position < container.children.length) {
                            container.insertBefore(itemElement, container.children[position]);
                        } else {
                            container.insertBefore(itemElement, container.firstChild);
                        }
                        
                        // Add click handler to make text editable when clicked
                        const textElement = itemElement.querySelector('.item-text');
                        textElement.addEventListener('click', function(e) {
                            // Prevent editing if cell is being edited by another user
                            if (textElement.classList.contains('cell-editing-other')) {
                                e.preventDefault();
                                return;
                            }
                            
                            if (textElement.getAttribute('contenteditable') === 'false') {
                                textElement.setAttribute('contenteditable', 'true');
                                textElement.focus();
                            }
                        });
                        
                        // Initialize drag and drop for this item
                        initializeDragForItem(itemElement);
                        
                        // Show a subtle notification that content was updated
                        const autoSaveIndicator = document.getElementById('auto-save-indicator');
                        autoSaveIndicator.innerHTML = 'Nytt objekt tillagt';
                        setTimeout(() => {
                            autoSaveIndicator.innerHTML = '';
                        }, 2000);
                    }
                }
            }
        }

        // Handle item reorder within same risk level
        function handleItemReorder(payload) {
            console.log('Item reorder update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId, newPosition } = payload.payload;
            console.log(`Reordering item to position ${newPosition}`);
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                // Find the container
                const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                    .find(row => row.querySelector('.entity-title').textContent === entityId);
                
                if (entityRow) {
                    const riskColumn = entityRow.querySelector(
                        riskLevel === 'No' ? '.no-risk' :
                        riskLevel === 'At' ? '.at-risk' :
                        '.high-risk'
                    );
                    
                    if (riskColumn) {
                        const container = riskColumn.querySelector('.items-container');
                        
                        // Only reorder if not being edited
                        if (!item.querySelector('.cell-editing') && !item.querySelector('.cell-editing-other')) {
                            
                            // Get current position before any DOM manipulation
                            const currentPosition = Array.from(container.children).indexOf(item);
                            console.log(`Current position: ${currentPosition}, target position: ${newPosition}`);
                            
                            // Only proceed if we're actually changing position
                            if (currentPosition !== newPosition) {
                                // Prevent item from dragging during reordering
                                item.setAttribute('draggable', 'false');
                                
                                // Add a temporary visual indication
                                item.style.transition = 'all 0.5s ease';
                                item.style.backgroundColor = 'rgba(13, 110, 253, 0.1)';
                                
                                // Create a clone of the item to prevent flicker
                                const clone = item.cloneNode(true);
                                
                                // Store current children before removing the item
                                const currentChildren = Array.from(container.children);
                                
                                // Remove the original item temporarily
                                item.remove();
                                
                                // Now determine where to insert it based on stored references
                                if (newPosition === 0) {
                                    // Special case for position 0
                                    container.insertBefore(clone, container.firstChild);
                                } else if (newPosition >= currentChildren.length) {
                                    // If the position is at or beyond the end, append to the end
                                    container.appendChild(clone);
                                } else {
                                    // Handle the case where we're moving an item UP (smaller position number)
                                    if (newPosition < currentPosition) {
                                        // When moving up, insert before the item that was at newPosition
                                        container.insertBefore(clone, currentChildren[newPosition]);
                                    } else {
                                        // When moving down, we need to adjust for the removed item
                                        // If moving down, insert after the item that was at (newPosition-1)
                                        if (newPosition < currentChildren.length) {
                                            container.insertBefore(clone, currentChildren[newPosition]);
                                        } else {
                                            container.appendChild(clone);
                                        }
                                    }
                                }
                                
                                // Store the position in a data attribute for verification
                                clone.setAttribute('data-position', newPosition.toString());
                                
                                // Verify final position
                                const finalPosition = Array.from(container.children).indexOf(clone);
                                console.log(`Final position verification: ${finalPosition} (expected ${newPosition})`);
                                
                                // Add event listeners and restore functionality to the clone
                                initializeDragForItem(clone);
                                clone.querySelector('.item-text').addEventListener('click', function(e) {
                                    // Prevent editing if cell is being edited by another user
                                    if (this.classList.contains('cell-editing-other')) {
                                        e.preventDefault();
                                        return;
                                    }
                                    
                                    if (this.getAttribute('contenteditable') === 'false') {
                                        this.setAttribute('contenteditable', 'true');
                                        this.focus();
                                    }
                                });
                                
                                // Animate the transition
                                setTimeout(() => {
                                    clone.style.backgroundColor = '';
                                    
                                    // Reset transition after animation completes
                                    setTimeout(() => {
                                        clone.style.transition = '';
                                    }, 500);
                                }, 500);
                                
                                // Show a subtle notification that content was updated
                                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                                autoSaveIndicator.innerHTML = 'Ordning √§ndrad';
                                setTimeout(() => {
                                    autoSaveIndicator.innerHTML = '';
                                }, 2000);
                            }
                        }
                    }
                }
            }
        }

        // Search functionality
        document.getElementById('interventionSearch').addEventListener('input', function() {
            console.log('Search input triggered with value:', this.value); // Debug logging
            const searchTerm = this.value.toLowerCase().trim();
            const allItems = document.querySelectorAll('.intervention-item');
            const categories = document.querySelectorAll('.intervention-category');
            let foundAny = false;
            
            console.log('Total items to search through:', allItems.length); // Debug logging
            
            // Reset display before searching
            allItems.forEach(item => {
                // If empty search term, show all items
                if (searchTerm === '') {
                    item.style.display = 'flex';
                    foundAny = true;
                    return;
                }
                
                // Get the text content of the entire item to include all child nodes
                const itemText = item.textContent.toLowerCase().trim();
                
                // Also specifically check the intervention-text span if it exists
                const textElement = item.querySelector('.intervention-text');
                const spanText = textElement ? textElement.textContent.toLowerCase().trim() : '';
                
                // Show item if either the full text or the span text includes the search term
                if (itemText.includes(searchTerm) || spanText.includes(searchTerm)) {
                    item.style.display = 'flex';
                    foundAny = true;
                    console.log('Match found in item:', itemText); // Debug logging
                } else {
                    item.style.display = 'none';
                }
            });
            
            // Show/hide categories based on if they have visible items
            categories.forEach(category => {
                // Count items that are not hidden by the search
                const visibleItemCount = Array.from(category.querySelectorAll('.intervention-item'))
                    .filter(item => item.style.display !== 'none').length;
                
                console.log('Category:', category.querySelector('h4')?.textContent, 'visible items:', visibleItemCount);
                
                // Always show "Mina interventionsf√∂rslag" category, hide others if empty
                const categoryTitle = category.querySelector('h4')?.textContent || '';
                if (visibleItemCount === 0 && categoryTitle !== 'Mina interventionsf√∂rslag') {
                    category.style.display = 'none';
                } else {
                    category.style.display = 'block';
                }
            });
            
            // Show no results message if needed
            let noResultsMsg = document.getElementById('noResultsMsg');
            if (!noResultsMsg) {
                noResultsMsg = document.createElement('div');
                noResultsMsg.id = 'noResultsMsg';
                noResultsMsg.className = 'no-results';
                noResultsMsg.textContent = 'Inga resultat hittades';
                document.getElementById('interventionPanel').appendChild(noResultsMsg);
            }
            
            noResultsMsg.style.display = foundAny ? 'none' : 'block';
            
            // Debug info
            console.log('Search results - Found any matches:', foundAny);
        });
        
        // Add custom intervention
        document.getElementById('addInterventionBtn').addEventListener('click', function() {
            addCustomIntervention();
        });
        
        // Add intervention on Enter key
        document.getElementById('newIntervention').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCustomIntervention();
            }
        });
        
        // Save custom intervention to the database
        function saveCustomIntervention(text) {
            // Call API to save the intervention as a resource
            fetch('/add_resource', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: text
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('Intervention saved to database:', data.resource);
                } else {
                    console.error('Error saving intervention:', data.message);
                }
            })
            .catch(error => {
                console.error('Error saving intervention:', error);
            });
        }
        
        // Load custom interventions from API
        function loadCustomInterventions() {
            // Clear existing interventions to prevent duplicates on reload
            const customInterventionsList = document.getElementById('customInterventions');
            customInterventionsList.innerHTML = '';
            
            // Fetch interventions from API
            fetch('/api/interventions')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.interventions && data.interventions.length > 0) {
                        data.interventions.forEach(resource => {
                            // Create new intervention item
                            const li = document.createElement('li');
                            li.className = 'intervention-item';
                            
                            // Add icon
                            const icon = document.createElement('i');
                            icon.className = 'bi bi-check-circle';
                            icon.style.marginRight = '8px'; // Add spacing between icon and text
                            li.appendChild(icon);
                            
                            // Add text as a separate element for better control
                            const textSpan = document.createElement('span');
                            textSpan.textContent = resource.text;
                            textSpan.className = 'intervention-text';
                            textSpan.style.flex = '1'; // Take up available space
                            
                            // Store resource ID for later deletion
                            textSpan.dataset.resourceId = resource.id;
                            
                            li.appendChild(textSpan);
                            
                            // Add click event for copying on item click
                            li.addEventListener('click', function(e) {
                                // Ignore clicks on delete button
                                if (e.target.closest('.delete-intervention')) {
                                    return;
                                }
                                
                                // Get text from the span
                                const textToCopy = textSpan.textContent.trim();
                                
                                // Store this as the last copied text for auto-filling
                                window.lastCopiedText = textToCopy;
                                
                                // Copy to clipboard
                                navigator.clipboard.writeText(textToCopy).then(() => {
                                    // Add copied class
                                    li.classList.add('copied');
                                    
                                    // Remove copied class after a delay
                                    setTimeout(() => {
                                        li.classList.remove('copied');
                                    }, 2000);
                                    
                                    // Show tooltip
                                    const tooltip = document.createElement('div');
                                    tooltip.className = 'copy-tooltip';
                                    tooltip.textContent = 'Kopierad!';
                                    li.appendChild(tooltip);
                                    
                                    // Remove tooltip after animation
                                    setTimeout(() => {
                                        tooltip.remove();
                                    }, 2000);
                                    
                                    // Show auto-save indicator if it exists
                                    const autoSaveIndicator = document.getElementById('autoSaveIndicator');
                                    if (autoSaveIndicator) {
                                        autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                                        setTimeout(() => {
                                            autoSaveIndicator.innerHTML = '';
                                        }, 3000);
                                    }
                                }).catch(err => {
                                    console.error('Kunde inte kopiera text: ', err);
                                });
                            });
                            
                            // Add delete button
                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'delete-intervention';
                            deleteBtn.title = 'Ta bort';
                            deleteBtn.innerHTML = '<i class="bi bi-x-circle"></i>';
                            deleteBtn.style.marginLeft = 'auto';
                            deleteBtn.style.background = 'transparent';
                            deleteBtn.style.border = 'none';
                            deleteBtn.style.color = '#dc3545';
                            deleteBtn.style.padding = '5px 8px';
                            deleteBtn.addEventListener('click', function(e) {
                                e.stopPropagation();
                                li.remove();
                                
                                // Delete from database
                                fetch(`/delete_resource/${resource.id}`, {
                                    method: 'DELETE'
                                })
                                .then(response => response.json())
                                .then(data => {
                                    if (data.status === 'success') {
                                        console.log('Intervention deleted from database');
                                    } else {
                                        console.error('Error deleting intervention:', data.message);
                                    }
                                })
                                .catch(error => {
                                    console.error('Error deleting intervention:', error);
                                });
                            });
                            li.appendChild(deleteBtn);
                            
                            // Add to list
                            customInterventionsList.appendChild(li);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error loading interventions:', error);
                });
        }
    </script>

    <!-- Intervention Button and Panel -->
    <div class="intervention-btn" id="interventionBtn">
        <i class="bi bi-clipboard-check"></i>
    </div>

    <div class="intervention-panel" id="interventionPanel">
        <h3>Interventionsf√∂rslag</h3>
        
        <div class="search-container">
            <input type="text" id="interventionSearch" class="intervention-search" placeholder="S√∂k interventioner...">
        </div>
        
        <div class="add-custom-intervention" style="margin-bottom: 15px;">
            <input type="text" id="newIntervention" placeholder="L√§gg till eget f√∂rslag...">
            <button id="addInterventionBtn"><i class="bi bi-plus-lg"></i></button>
        </div>
        
        <div class="intervention-category">
            <h4>Mina interventionsf√∂rslag</h4>
            <ul class="intervention-list" id="customInterventions">
                <!-- Anpassade interventionsf√∂rslag kommer l√§ggas till h√§r -->
            </ul>
        </div>
        
        <div class="intervention-category">
            <h4>Arbetsmilj√∂ & S√§kerhet</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Arbetsmilj√∂genomg√•ng<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Introduktion till arbetsmilj√∂ f√∂r nyanst√§llda<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Arbetsmilj√∂policy<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Arbetsmilj√∂utbildning<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>√Örlig uppf√∂ljning av systematiskt arbetsmilj√∂arbete (SAM)<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Avvikelserapporteringssystem f√∂r arbetsmilj√∂<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Egeninspektion av arbetsmilj√∂<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Policy f√∂r alkohol och droger<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Systematiskt arbetsmilj√∂arbete och anpassningsprocesser<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Riskbed√∂mningar p√• arbetsplatsen<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Samverkan med skyddsombud<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Visselbl√•sarsystem<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Ergonomisk arbetsplatsanalys<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>

        <div class="intervention-category">
            <h4>H√§lsa & Friskv√•rd</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Stresshanteringskurser<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Ergonomiskt st√∂d och utbildning<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>H√§lsosamtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Feelgoodsamtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Friskv√•rdsbidrag<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>H√§lsounders√∂kningar<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Medicinska kontroller<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Livsstilsverktyg<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Fysisk aktivitet p√• arbetstid<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Tillg√•ng till f√∂retagsh√§lsov√•rd<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>

        <div class="intervention-category">
            <h4>Medarbetarst√∂d & Utveckling</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Regelbundna utvecklingssamtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>St√∂dsamtal vid behov<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Coachning f√∂r medarbetare<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Kompetensutveckling<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Karri√§rplanering<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Mentorskapsprogram<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Krishantering och akut st√∂d<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Konflikthantering<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>F√∂rb√§ttringsdialog<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>F√∂rm√•nsportal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>
        
        <div class="intervention-category">
            <h4>Ledarskap & Chefsst√∂d</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Ledarskapsutbildning f√∂r chefer<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Coachning f√∂r chefer<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Feedback-workshops<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Konflikthanteringsutbildning<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>HR Business Partner-st√∂d<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>St√∂d i sv√•ra samtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Chefsenk√§t<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>

        <div class="intervention-category">
            <h4>Organisationsutveckling</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Teambuilding-aktiviteter<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Medarbetarunders√∂kningar<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>F√∂rb√§ttringsworkshops<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Optimering av arbetsfl√∂den<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Delaktighetsm√∂ten (APT)<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>M√•ngfaldsarbete<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>

        <div class="intervention-category">
            <h4>Uppf√∂ljning & Rehabilitering</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Sjukfr√•nvarouppf√∂ljning (kort- och l√•ngtidsfr√•nvaro)<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Rehabiliteringssamtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Rehabiliteringsplan<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Arbetsanpassning<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Uppf√∂ljningssystem f√∂r h√§lsoplaner<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Tidig signalering vid upprepad sjukfr√•nvaro<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>
    </div>

    <script>
        // Toggle intervention panel
        document.getElementById('interventionBtn').addEventListener('click', function() {
            document.getElementById('interventionPanel').classList.toggle('active');
        });

        // Close panel when clicking outside
        document.addEventListener('click', function(event) {
            const panel = document.getElementById('interventionPanel');
            const btn = document.getElementById('interventionBtn');
            
            if (!panel.contains(event.target) && event.target !== btn && !btn.contains(event.target)) {
                panel.classList.remove('active');
            }
        });

        // Drag and drop functionality for interventions
        document.addEventListener('DOMContentLoaded', function() {
            // Setup drag and drop for all intervention items
            setupDragAndDrop();
            
            // Load custom interventions
            loadCustomInterventions();
            
            // Setup copy buttons
            setupCopyButtons();
            
            // Track last copied text for auto-filling
            window.lastCopiedText = "";
            
            // Restore periodic cleanup to keep UI clean
            setInterval(function() {
                // If no drag operation is in progress (no element has 'dragging' class)
                if (!document.querySelector('.dragging')) {
                    // Clean up any cells that might still have the drag-over class
                    const riskCells = document.querySelectorAll('.no-risk, .at-risk, .high-risk');
                    riskCells.forEach(cell => {
                        if (cell.classList.contains('drag-over')) {
                            cell.classList.remove('drag-over');
                        }
                    });
                    
                    // Also clean up any container-drag-over classes
                    const containers = document.querySelectorAll('.container-drag-over');
                    containers.forEach(container => {
                        container.classList.remove('container-drag-over');
                    });
                }
            }, 2000); // Check every 2 seconds
        });
        
        function setupCopyButtons() {
            // Add click event to all copy buttons
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent item click
                    
                    // Get the text from the parent intervention item
                    const item = this.closest('.intervention-item');
                    const text = item.textContent.replace('Kopiera', '').trim();
                    
                    // Copy to clipboard
                    navigator.clipboard.writeText(text).then(() => {
                        // Save last copied text for auto-filling
                        window.lastCopiedText = text;
                        
                        // Show success message
                        const originalIcon = this.innerHTML;
                        this.innerHTML = '<i class="bi bi-check2"></i>';
                        this.title = 'Kopierad!';
                        
                        // Reset after a moment
                        setTimeout(() => {
                            this.innerHTML = originalIcon;
                            this.title = 'Kopiera';
                        }, 1500);
                        
                        // Show notification
                        const autoSaveIndicator = document.getElementById('auto-save-indicator');
                        if (autoSaveIndicator) {
                            autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                            setTimeout(() => {
                                autoSaveIndicator.innerHTML = '';
                            }, 2000);
                        }
                    }).catch(err => {
                        console.error('Kunde inte kopiera text: ', err);
                    });
                });
            });
        }
        
        function setupDragAndDrop() {
            const interventionItems = document.querySelectorAll('.intervention-item');
            
            interventionItems.forEach(item => {
                // Remove draggable attribute
                item.removeAttribute('draggable');
                
                // Make the entire item clickable to copy text
                item.addEventListener('click', function(e) {
                    // Only if not clicking the copy button or delete button
                    if (!e.target.closest('.copy-btn') && !e.target.closest('.delete-intervention')) {
                        const text = this.textContent.replace('Kopiera', '').trim();
                        
                        // Copy text to clipboard
                        navigator.clipboard.writeText(text).then(() => {
                            // Store the last copied text for auto-filling
                            window.lastCopiedText = text;
                            
                            // Show tooltip notification
                            showCopyTooltip(this, 'Kopierad! Tryck p√• plus-knappen i en riskcell f√∂r att l√§gga till texten');
                            
                            // Show notification in auto-save indicator
                            const autoSaveIndicator = document.getElementById('auto-save-indicator');
                            if (autoSaveIndicator) {
                                autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                                setTimeout(() => {
                                    autoSaveIndicator.innerHTML = '';
                                }, 2000);
                            }
                        }).catch(err => {
                            console.error('Kunde inte kopiera text: ', err);
                        });
                    }
                });
            });
            
            // Restore drag functionality for items in risk cells
            const riskItems = document.querySelectorAll('.risk-column .item');
            riskItems.forEach(item => {
                // Ensure the item is draggable
                item.setAttribute('draggable', 'true');
                // Initialize drag and drop
                initializeDragForItem(item);
            });
            
            // Make sure risk cells can handle the dropping
            const riskCells = document.querySelectorAll('.no-risk, .at-risk, .high-risk');
            riskCells.forEach(cell => {
                // Ensure no drag-over classes are left
                cell.classList.remove('drag-over');
            });
        }
        
        // Helper function to show a tooltip on an intervention item
        function showCopyTooltip(element, message) {
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'copy-tooltip';
            tooltip.textContent = message;
            
            // Position tooltip
            element.style.position = 'relative';
            element.appendChild(tooltip);
            
            // Apply a highlight effect to the item
            element.classList.add('copied');
            
            // Remove tooltip after 3.5 seconds
            setTimeout(() => {
                tooltip.remove();
                // Don't remove copied class here since we're already handling it in the click event
            }, 3500);
        }
        
        function handleDragStart(e) {
            // Add a class to show it's being dragged
            this.classList.add('dragging');
            
            // Set the data being dragged
            // Get only the text content, excluding the rating
            const textOnly = this.querySelector('.item-text') ? 
                this.querySelector('.item-text').textContent : 
                this.textContent.replace('Kopiera', '').trim();
            
            e.dataTransfer.setData('text/plain', textOnly);
            
            // Set how it looks when dragged
            if (e.dataTransfer.setDragImage) {
                const dragIcon = document.createElement('div');
                dragIcon.textContent = textOnly;
                dragIcon.style.backgroundColor = '#5D6D7E';
                dragIcon.style.color = 'white';
                dragIcon.style.padding = '10px';
                dragIcon.style.borderRadius = '6px';
                dragIcon.style.position = 'absolute';
                dragIcon.style.top = '-1000px';
                document.body.appendChild(dragIcon);
                
                e.dataTransfer.setDragImage(dragIcon, 0, 0);
                
                // Remove the temporary element after a bit
                setTimeout(() => {
                    document.body.removeChild(dragIcon);
                }, 0);
            }
            
            // Listen for drag end
            this.addEventListener('dragend', function() {
                this.classList.remove('dragging');
            }, { once: true });
        }
        
        function createStandardItem(cell, interventionText) {
            // This is a fallback in case addNewItem function doesn't exist
            // Try to mimic how new items are normally created
            
            // If no intervention text is provided, use the last copied text if available
            if (!interventionText && window.lastCopiedText) {
                interventionText = window.lastCopiedText;
                // Clear it so it's only used once
                window.lastCopiedText = "";
            }
            
            // If still no text, return without creating an item
            if (!interventionText) {
                return;
            }
            
            // Clean the text (remove icon text and copy button text)
            const cleanText = interventionText.replace(/^[\u2713\u2714\‚úì\‚úî\u2705\u25A0\‚Ä¢\‚ó¶\-\+\*]+\s*/, '').replace('Kopiera', '').trim();
            
            // Check if cell is part of the current visible category/tab
            const row = cell.closest('.entity-row');
            if (!row || row.getAttribute('data-category') !== currentCategory) {
                console.log('Not adding intervention to cell of different category');
                return;
            }
            
            // Create an input element to simulate user input
            const fakeInput = document.createElement('input');
            fakeInput.value = cleanText;
            
            // Try to find the add button in the cell and trigger its click handler
            const addBtn = cell.querySelector('.add-item-btn');
            if (addBtn) {
                // Create a custom event
                const clickEvent = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                
                // Set current input field for the handlers
                window.currentAddInput = fakeInput;
                
                // Dispatch the event
                addBtn.dispatchEvent(clickEvent);
            } else {
                // Fallback to manual insertion
                console.log('No add button found, manually inserting item');
                
                // Create a new item based on others in the cell
                const container = cell.querySelector('.items-container');
                if (container) {
                    // Create a new element similar to existing ones
                    const newItem = document.createElement('div');
                    newItem.className = 'item';
                    newItem.setAttribute('draggable', 'true');
                    newItem.setAttribute('data-category', currentCategory);
                    
                    // Create content element
                    const content = document.createElement('div');
                    content.className = 'item-content';
                    content.textContent = cleanText;
                    newItem.appendChild(content);
                    
                    // Add delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '<i class="bi bi-x"></i>';
                    deleteBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        newItem.remove();
                    });
                    newItem.appendChild(deleteBtn);
                    
                    // Add to container
                    container.appendChild(newItem);
                }
            }
            
            // Show notification
            const autoSaveIndicator = document.getElementById('auto-save-indicator');
            if (autoSaveIndicator) {
                autoSaveIndicator.innerHTML = 'Intervention tillagd';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Function to add custom intervention
        function addCustomIntervention() {
            const input = document.getElementById('newIntervention');
            const text = input.value.trim();
            
            if (text) {
                // Save to database first
                saveCustomIntervention(text);
                
                // Create new intervention item in UI
                const li = document.createElement('li');
                li.className = 'intervention-item';
                
                // Add icon
                const icon = document.createElement('i');
                icon.className = 'bi bi-check-circle';
                icon.style.marginRight = '8px'; // Add spacing between icon and text
                li.appendChild(icon);
                
                // Add text as a separate element for better control
                const textSpan = document.createElement('span');
                textSpan.textContent = text;
                textSpan.className = 'intervention-text';
                textSpan.style.flex = '1'; // Take up available space
                li.appendChild(textSpan);
                
                // Add click event for copying on item click
                li.addEventListener('click', function(e) {
                    // Ignore clicks on delete button
                    if (e.target.closest('.delete-intervention')) {
                        return;
                    }
                    
                    // Get text from the span
                    const textToCopy = textSpan.textContent.trim();
                    
                    // Store this as the last copied text for auto-filling
                    window.lastCopiedText = textToCopy;
                    
                    // Copy to clipboard
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        // Add copied class
                        li.classList.add('copied');
                        
                        // Remove copied class after a delay
                        setTimeout(() => {
                            li.classList.remove('copied');
                        }, 2000);
                        
                        // Show tooltip
                        const tooltip = document.createElement('div');
                        tooltip.className = 'copy-tooltip';
                        tooltip.textContent = 'Kopierad!';
                        li.appendChild(tooltip);
                        
                        // Remove tooltip after animation
                        setTimeout(() => {
                            tooltip.remove();
                        }, 2000);
                        
                        // Show auto-save indicator if it exists
                        const autoSaveIndicator = document.getElementById('autoSaveIndicator');
                        if (autoSaveIndicator) {
                            autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                            setTimeout(() => {
                                autoSaveIndicator.innerHTML = '';
                            }, 3000);
                        }
                    }).catch(err => {
                        console.error('Kunde inte kopiera text: ', err);
                    });
                });
                
                // Add delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-intervention';
                deleteBtn.title = 'Ta bort';
                deleteBtn.innerHTML = '<i class="bi bi-x-circle"></i>';
                deleteBtn.style.marginLeft = 'auto';
                deleteBtn.style.background = 'transparent';
                deleteBtn.style.border = 'none';
                deleteBtn.style.color = '#dc3545';
                deleteBtn.style.padding = '5px 8px';
                deleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    li.remove();
                    
                    // Delete from database by calling the API endpoint
                    if (textSpan.dataset.resourceId) {
                        fetch(`/delete_resource/${textSpan.dataset.resourceId}`, {
                            method: 'DELETE'
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success') {
                                console.log('Intervention deleted from database');
                            } else {
                                console.error('Error deleting intervention:', data.message);
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting intervention:', error);
                        });
                    }
                });
                li.appendChild(deleteBtn);
                
                // Add to list
                document.getElementById('customInterventions').appendChild(li);
                
                // Clear input
                input.value = '';
            }
        }
        
        // Search functionality
        document.getElementById('interventionSearch').addEventListener('input', function() {
            console.log('Search input triggered with value:', this.value); // Debug logging
            const searchTerm = this.value.toLowerCase().trim();
            const allItems = document.querySelectorAll('.intervention-item');
            const categories = document.querySelectorAll('.intervention-category');
            let foundAny = false;
            
            console.log('Total items to search through:', allItems.length); // Debug logging
            
            // Reset display before searching
            allItems.forEach(item => {
                // If empty search term, show all items
                if (searchTerm === '') {
                    item.style.display = 'flex';
                    foundAny = true;
                    return;
                }
                
                // Get the text content of the entire item to include all child nodes
                const itemText = item.textContent.toLowerCase().trim();
                
                // Also specifically check the intervention-text span if it exists
                const textElement = item.querySelector('.intervention-text');
                const spanText = textElement ? textElement.textContent.toLowerCase().trim() : '';
                
                // Show item if either the full text or the span text includes the search term
                if (itemText.includes(searchTerm) || spanText.includes(searchTerm)) {
                    item.style.display = 'flex';
                    foundAny = true;
                    console.log('Match found in item:', itemText); // Debug logging
                } else {
                    item.style.display = 'none';
                }
            });
            
            // Show/hide categories based on if they have visible items
            categories.forEach(category => {
                // Count items that are not hidden by the search
                const visibleItemCount = Array.from(category.querySelectorAll('.intervention-item'))
                    .filter(item => item.style.display !== 'none').length;
                
                console.log('Category:', category.querySelector('h4')?.textContent, 'visible items:', visibleItemCount);
                
                // Always show "Mina interventionsf√∂rslag" category, hide others if empty
                const categoryTitle = category.querySelector('h4')?.textContent || '';
                if (visibleItemCount === 0 && categoryTitle !== 'Mina interventionsf√∂rslag') {
                    category.style.display = 'none';
                } else {
                    category.style.display = 'block';
                }
            });
            
            // Show no results message if needed
            let noResultsMsg = document.getElementById('noResultsMsg');
            if (!noResultsMsg) {
                noResultsMsg = document.createElement('div');
                noResultsMsg.id = 'noResultsMsg';
                noResultsMsg.className = 'no-results';
                noResultsMsg.textContent = 'Inga resultat hittades';
                document.getElementById('interventionPanel').appendChild(noResultsMsg);
            }
            
            noResultsMsg.style.display = foundAny ? 'none' : 'block';
            
            // Debug info
            console.log('Search results - Found any matches:', foundAny);
        });
        
        // Add custom intervention
        document.getElementById('addInterventionBtn').addEventListener('click', function() {
            addCustomIntervention();
        });
        
        // Add intervention on Enter key
        document.getElementById('newIntervention').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCustomIntervention();
            }
        });
        
        // Save custom intervention to the database
        function saveCustomIntervention(text) {
            // Call API to save the intervention as a resource
            fetch('/add_resource', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: text
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('Intervention saved to database:', data.resource);
                } else {
                    console.error('Error saving intervention:', data.message);
                }
            })
            .catch(error => {
                console.error('Error saving intervention:', error);
            });
        }
        
        // Load custom interventions from API
        function loadCustomInterventions() {
            // Clear existing interventions to prevent duplicates on reload
            const customInterventionsList = document.getElementById('customInterventions');
            customInterventionsList.innerHTML = '';
            
            // Fetch interventions from API
            fetch('/api/interventions')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.interventions && data.interventions.length > 0) {
                        data.interventions.forEach(resource => {
                            // Create new intervention item
                            const li = document.createElement('li');
                            li.className = 'intervention-item';
                            
                            // Add icon
                            const icon = document.createElement('i');
                            icon.className = 'bi bi-check-circle';
                            icon.style.marginRight = '8px'; // Add spacing between icon and text
                            li.appendChild(icon);
                            
                            // Add text as a separate element for better control
                            const textSpan = document.createElement('span');
                            textSpan.textContent = resource.text;
                            textSpan.className = 'intervention-text';
                            textSpan.style.flex = '1'; // Take up available space
                            
                            // Store resource ID for later deletion
                            textSpan.dataset.resourceId = resource.id;
                            
                            li.appendChild(textSpan);
                            
                            // Add click event for copying on item click
                            li.addEventListener('click', function(e) {
                                // Ignore clicks on delete button
                                if (e.target.closest('.delete-intervention')) {
                                    return;
                                }
                                
                                // Get text from the span
                                const textToCopy = textSpan.textContent.trim();
                                
                                // Store this as the last copied text for auto-filling
                                window.lastCopiedText = textToCopy;
                                
                                // Copy to clipboard
                                navigator.clipboard.writeText(textToCopy).then(() => {
                                    // Add copied class
                                    li.classList.add('copied');
                                    
                                    // Remove copied class after a delay
                                    setTimeout(() => {
                                        li.classList.remove('copied');
                                    }, 2000);
                                    
                                    // Show tooltip
                                    const tooltip = document.createElement('div');
                                    tooltip.className = 'copy-tooltip';
                                    tooltip.textContent = 'Kopierad!';
                                    li.appendChild(tooltip);
                                    
                                    // Remove tooltip after animation
                                    setTimeout(() => {
                                        tooltip.remove();
                                    }, 2000);
                                    
                                    // Show auto-save indicator if it exists
                                    const autoSaveIndicator = document.getElementById('autoSaveIndicator');
                                    if (autoSaveIndicator) {
                                        autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                                        setTimeout(() => {
                                            autoSaveIndicator.innerHTML = '';
                                        }, 3000);
                                    }
                                }).catch(err => {
                                    console.error('Kunde inte kopiera text: ', err);
                                });
                            });
                            
                            // Add delete button
                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'delete-intervention';
                            deleteBtn.title = 'Ta bort';
                            deleteBtn.innerHTML = '<i class="bi bi-x-circle"></i>';
                            deleteBtn.style.marginLeft = 'auto';
                            deleteBtn.style.background = 'transparent';
                            deleteBtn.style.border = 'none';
                            deleteBtn.style.color = '#dc3545';
                            deleteBtn.style.padding = '5px 8px';
                            deleteBtn.addEventListener('click', function(e) {
                                e.stopPropagation();
                                li.remove();
                                
                                // Delete from database
                                fetch(`/delete_resource/${resource.id}`, {
                                    method: 'DELETE'
                                })
                                .then(response => response.json())
                                .then(data => {
                                    if (data.status === 'success') {
                                        console.log('Intervention deleted from database');
                                    } else {
                                        console.error('Error deleting intervention:', data.message);
                                    }
                                })
                                .catch(error => {
                                    console.error('Error deleting intervention:', error);
                                });
                            });
                            li.appendChild(deleteBtn);
                            
                            // Add to list
                            customInterventionsList.appendChild(li);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error loading interventions:', error);
                });
        }
    </script>
</body>
</html>
