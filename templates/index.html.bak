<!DOCTYPE html>
<html lang="en" class="index-page">
<head>
    <title>SENTION Dashboard</title>
    <link rel="icon" type="image/png" href="https://i.postimg.cc/FRwbMSBN/SENTION-logo-Black-Transparent-BG.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Popup Tooltip styles - more like the example image */
        .info-tooltip {
            position: relative;
            cursor: pointer;
            display: inline-block;
        }
        
        .navbar-links .info-tooltip {
            margin: 0 2px;
        }
        
        .navbar-links .info-tooltip a {
            display: inline-block;
            padding: 10px 15px;
            text-decoration: none;
            color: #333;
            transition: all 0.2s;
            border-radius: 4px;
            font-weight: 500;
            position: relative;
        }
        
        .navbar-links .info-tooltip a::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 10%;
            width: 80%;
            height: 2px;
            background: #8c857d;
            transform: scaleX(0);
            transition: transform 0.3s;
        }
        
        .navbar-links .info-tooltip a:hover {
            background-color: rgba(240, 244, 248, 0.5);
            color: #000;
        }
        
        .navbar-links .info-tooltip a:hover::before {
            transform: scaleX(1);
        }
        
        .navbar-links .info-tooltip a.active {
            background: linear-gradient(135deg, rgba(167, 163, 158, 0.1) 0%, rgba(140, 133, 125, 0.2) 100%);
            color: #000;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .navbar-links .info-tooltip a.active::before {
            transform: scaleX(1);
            background: linear-gradient(90deg, transparent, #8c857d, transparent);
            height: 3px;
        }
        
        /* Right nav buttons tooltip styles */
        .nav-buttons .info-tooltip {
            margin: 0 2px;
            display: inline-block;
        }
        
        .nav-buttons .info-tooltip a {
            display: inline-block;
        }
        
        .nav-buttons .info-tooltip-content {
            right: 0;
            left: auto;
            transform: none;
        }
        
        .nav-buttons .info-tooltip-content::after {
            left: 75%;
        }
        
        .info-tooltip-content {
            display: none;
            position: absolute;
            top: 100%; /* Position below the navbar instead of above */
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 200px;
            padding: 20px;
            text-align: center;
            z-index: 1000;
            margin-top: 10px; /* Add some space between navbar and tooltip */
        }
        
        /* Arrow on tooltip - pointing up instead of down */
        .info-tooltip-content::after {
            content: "";
            position: absolute;
            top: -10px; /* Position above the tooltip box */
            left: 50%;
            margin-left: -10px;
            border-width: 10px;
            border-style: solid;
            border-color: transparent transparent white transparent; /* Arrow pointing up */
        }
        
        .info-icon {
            display: block;
            width: 40px;
            height: 40px;
            background-color: #f0f0f0;
            border-radius: 50%;
            margin: 0 auto 15px;
            line-height: 40px;
            font-size: 18px;
        }
        
        .info-tooltip-text {
            color: #333;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        /* Show the tooltip when hovering */
        .info-tooltip:hover .info-tooltip-content {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes tooltip-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Rating selector styles */
        .rating-selector {
            position: absolute;
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 10px;
            z-index: 1000;
            display: none;
        }
        
        .rating-option {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .rating-option:hover {
            background-color: #f0f0f0;
        }
        
        .rating-option.highlighted {
            background-color: #e0f0ff;
        }
        
        /* Intervention icon button styles */
        .intervention-btn {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: #5D6D7E; /* Ändrat till en mer diskret mörk blågrå ton */
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .intervention-btn:hover {
            background-color: #34495E; /* Mörkare diskret ton vid hover */
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        
        .intervention-btn i {
            font-size: 24px;
        }
        
        /* Intervention panel styles */
        .intervention-panel {
            display: none;
            position: fixed;
            bottom: 90px;
            left: 30px;
            width: 350px;
            max-height: 70vh;
            overflow-y: auto;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
            z-index: 999;
            padding: 20px;
        }
        
        .intervention-panel.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }
        
        .intervention-panel h3 {
            margin-top: 0;
            color: #333;
            font-weight: 600;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 15px;
            color: #5D6D7E; /* Ändrat till samma diskreta ton */
        }
        
        .intervention-category {
            margin-bottom: 20px;
            border-left: 3px solid #5D6D7E; /* Ändrat till samma diskreta ton */
            padding-left: 12px;
        }
        
        .intervention-category h4 {
            color: #5D6D7E; /* Ändrat till samma diskreta ton */
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .intervention-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .intervention-item {
            padding: 8px 12px;
            margin-bottom: 6px;
            background-color: #f5f5f5;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            position: relative;
        }
        
        .intervention-item:hover {
            background-color: #EBF0F5; /* Ändrat till en ljusare diskret blågrå */
            transform: translateX(5px);
        }
        
        /* Style for copied items to provide visual feedback */
        .intervention-item.copied {
            background-color: #e0f3e0; /* Light green background */
            border-left: 3px solid #28a745; /* Green border */
            animation: highlight-copied 2s ease;
        }
        
        @keyframes highlight-copied {
            0% { background-color: #c8e6c9; }
            100% { background-color: #e0f3e0; }
        }
        
        /* Add specific styles for the delete button in intervention items */
        .delete-intervention {
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s ease;
            z-index: 10;
            position: relative;
            padding: 5px;
        }
        
        .delete-intervention:hover {
            opacity: 1;
            transform: scale(1.2);
            color: #b30000 !important;
        }
        
        /* Tooltip style modifications */
        .copy-tooltip {
            animation-duration: 3s !important; /* Extended from default */
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }
        
        /* Add a little arrow to the tooltip */
        .copy-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.8) transparent transparent transparent;
        }
        
        .intervention-item i {
            margin-right: 10px;
            color: #5D6D7E; /* Ändrat till samma diskreta ton */
        }
        
        .intervention-item .copy-btn {
            position: absolute;
            right: 10px;
            background: transparent;
            border: none;
            color: #5D6D7E;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .intervention-item:hover .copy-btn {
            opacity: 1;
        }
        
        /* Copy tooltip styles */
        .copy-tooltip {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(93, 109, 126, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            animation: fadeInOut 2s forwards;
        }
        
        /* Copied state styles */
        .intervention-item.copied {
            background-color: rgba(93, 109, 126, 0.2);
            box-shadow: 0 0 0 2px rgba(93, 109, 126, 0.5);
        }
        
        /* Animation for the tooltip */
        @keyframes fadeInOut {
            0% { opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Add button styles */
        .add-item-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border-radius: 6px;
            background-color: #F0EEEC;
            color: #333;
            border: none;
            cursor: pointer;
            margin: 10px auto;
        }

        .add-item-btn:hover {
            background-color: #e0dedc;
        }

        /* Item styles */
        .item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin: 5px;
            background-color: #F7F6F5;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: default;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
        }

        .item:hover {
            background-color: #F0EEEC;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        /* Drag handle styles */
        .drag-handle {
            cursor: grab;
            color: #6c757d;
            padding: 5px;
            margin-right: 5px;
            opacity: 0.5;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }
        
        .drag-handle:hover {
            opacity: 1;
            transform: scale(1.2);
            color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.1);
            border-radius: 4px;
        }
        
        .drag-handle:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        
        .drag-handle::after {
            content: 'Dra för att ändra ordning';
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            z-index: 1000;
        }
        
        .drag-handle:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        /* Dragging styles */
        .item.dragging {
            background-color: rgba(13, 110, 253, 0.1) !important;
            opacity: 0.8;
            cursor: grabbing;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transform: scale(1.02);
            border: 1px dashed #0d6efd;
            z-index: 100;
        }
        
        .item.drag-over {
            position: relative;
        }
        
        .item.drag-over::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: -2px;
            height: 4px;
            background-color: #0d6efd;
            z-index: 100;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            animation: pulse 1.5s infinite;
        }

        /* Container drag-over styles */
        .items-container.container-drag-over {
            background-color: rgba(13, 110, 253, 0.1);
            border: 2px dashed #0d6efd;
            border-radius: 6px;
            padding: 10px;
            min-height: 60px;
            animation: pulse 1.5s infinite;
        }

        /* Empty container styles */
        .items-container {
            width: 100%;
            min-height: 50px; /* Ensure empty containers have some height */
            transition: all 0.2s ease;
        }

        .item-text {
            flex-grow: 1;
            margin-right: 10px;
            min-height: 20px;
        }

        .item-text[contenteditable="true"] {
            padding: 2px;
            outline: none;
        }

        .item-rating {
            padding: 2px 5px;
            color: #666;
            min-width: 60px;
            text-align: center;
        }
        
        /* Add placeholder for empty rating */
        .item-rating:empty::before {
            content: "Klicka för betyg";
            font-style: italic;
            color: #aaa;
            font-size: 0.85em;
        }

        /* Delete button styles */
        .delete-btn {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .item:hover .delete-btn {
            opacity: 1;
        }
        
        .delete-btn:hover {
            color: #bd2130;
        }

        /* Edit mode styles */
        .editing {
            background-color: #fff;
            box-shadow: 0 0 0 2px #007bff;
        }

        .editing .delete-btn {
            opacity: 1;
        }

        /* Entity row styles */
        .entity-row {
            margin: 20px;
            width: calc(100% - 40px); /* Full width minus margins */
            max-width: 100%;
            box-sizing: border-box;
        }

        .risk-columns {
            display: flex;
            gap: 20px;
            width: 100%;
            margin-top: 10px;
        }

        .risk-column {
            flex: 1;
            border-radius: 8px;
            padding: 15px;
            min-width: 0; /* Prevents flex items from overflowing */
        }

        .risk-column.no-risk {
            background-color: rgba(40, 167, 69, 0.1); /* Light green */
        }

        .risk-column.at-risk {
            background-color: rgba(255, 193, 7, 0.1); /* Light yellow */
        }

        .risk-column.high-risk {
            background-color: rgba(220, 53, 69, 0.1); /* Light red */
        }

        /* Cell being edited styles */
        .cell-editing {
            background-color: rgba(255, 255, 0, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5);
            position: relative;
        }

        .cell-editing::after {
            content: "Redigeras...";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        /* Cell being edited by another user */
        .cell-editing-other {
            background-color: rgba(255, 0, 0, 0.1) !important;
            position: relative;
        }

        .cell-editing-other::after {
            content: "Redigeras av annan användare";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        /* Status message styles */
        .status-message {
            margin: 15px 20px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        
        .success-message {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* Auto-save indicator */
        .auto-save-indicator {
            display: inline-block;
            margin: 15px 20px;
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        /* Saving animation */
        .saving {
            display: inline-block;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        /* First-time user hint */
        .drag-hint {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            padding: 20px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            max-width: 450px; /* Öka från tidigare värde */
            width: 90%;
            max-height: 80vh; /* Begränsa höjden så att den inte tar upp hela skärmen */
            overflow-y: auto; /* Lägg till scrollning om innehållet blir för stort */
        }
        
        .drag-hint-content {
            margin-bottom: 15px;
            font-size: 15px; /* Öka textstorleken lite */
            line-height: 1.5; /* Öka radavståndet för bättre läsbarhet */
            position: relative;
            padding: 0 5px;
        }
        
        #drag-hint-text {
            display: block;
            padding: 8px 0;
            transition: opacity 0.3s ease;
            opacity: 1;
        }
        
        #drag-hint-text.fade {
            opacity: 0;
        }
        
        /* Icon styling in tips */
        #drag-hint-text i {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: -0.125em;
            margin: 0 3px;
        }
        
        .drag-hint-tip {
            margin-bottom: 10px;
            display: flex;
            align-items: flex-start;
        }
        
        /* Improved tip navigation styling */
        .tip-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 12px;
            border-top: 1px solid #eee;
            padding-top: 12px;
        }
        
        .tip-nav-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
            background-color: #f0f7ff;
            border: 1px solid #d0e3ff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #0d6efd;
            font-size: 0.9rem;
            padding: 0;
            margin: 0 8px;
        }
        
        .tip-nav-btn:hover {
            background-color: #e0f0ff;
            transform: scale(1.05);
        }
        
        .tip-nav-btn:active {
            transform: scale(0.95);
        }
        
        .tip-counter {
            font-size: 14px;
            color: #6c757d;
            margin: 0 10px;
            min-width: 40px;
            text-align: center;
        }
        
        .drag-hint i {
            font-size: 1.2rem;
            color: #0d6efd;
        }
        
        .drag-hint-close {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            color: #999;
            transition: color 0.2s;
            font-size: 16px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .drag-hint-close:hover {
            color: #666;
            background-color: #f0f0f0;
        }
        
        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 1050;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: #333;
        }
        
        .shortcuts-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .shortcuts-table tr {
            border-bottom: 1px solid #eee;
        }
        
        .shortcuts-table tr:last-child {
            border-bottom: none;
        }
        
        .shortcuts-table td {
            padding: 8px 5px;
        }
        
        .shortcuts-table td:first-child {
            width: 40%;
            text-align: right;
            padding-right: 15px;
        }
        
        kbd {
            background-color: #f7f7f7;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
            color: #333;
            display: inline-block;
            font-size: 0.85em;
            font-family: monospace;
            line-height: 1;
            padding: 2px 5px;
            margin: 0 2px;
        }
        
        /* Help button styles */
        .help-btn {
            background-color: #6c757d;
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            text-decoration: none;
            margin-left: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            transition: background-color 0.2s;
        }
        
        .help-btn:hover {
            background-color: #5a6268;
            color: white;
        }
        
        .help-btn i {
            font-size: 1.1rem;
        }
        
        /* Welcome modal styles */
        .welcome-content {
            max-width: 600px;
            padding: 25px;
        }
        
        .welcome-steps {
            margin: 20px 0;
        }
        
        .welcome-step {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }
        
        .step-number {
            background-color: #0d6efd;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex-grow: 1;
        }
        
        .step-content h4 {
            margin: 0 0 5px 0;
            color: #333;
        }
        
        .step-content p {
            margin: 0;
            color: #666;
            line-height: 1.5;
        }
        
        .welcome-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        .welcome-btn {
            background-color: #0d6efd;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .welcome-btn:hover {
            background-color: #0b5ed7;
        }
        
        .dont-show-again {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #666;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* Help floating button */
        .help-floating-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #0d6efd;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 999;
            transition: all 0.2s;
            opacity: 0;
            visibility: hidden;
        }
        
        .help-floating-btn.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .help-floating-btn:hover {
            transform: scale(1.1);
            background-color: #0b5ed7;
        }
        
        .help-floating-btn i {
            font-size: 1.2rem;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Container styles to ensure consistent margins */
        .container {
            margin: 0 20px;
            width: calc(100% - 40px);
            box-sizing: border-box;
        }

        /* Search container styles */
        .search-container {
            margin-bottom: 15px;
        }
        
        .intervention-search {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .intervention-search:focus {
            border-color: #5D6D7E; /* Ändrat till samma diskreta ton */
            box-shadow: 0 0 0 2px rgba(93, 109, 126, 0.2); /* Ändrat till samma diskreta ton */
            outline: none;
        }
        
        /* Custom intervention styles */
        .add-custom-intervention {
            display: flex;
            margin-top: 10px;
        }
        
        .add-custom-intervention input {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 6px 0 0 6px;
            font-size: 14px;
        }
        
        .add-custom-intervention input:focus {
            border-color: #5D6D7E; /* Ändrat till samma diskreta ton */
            outline: none;
        }
        
        .add-custom-intervention button {
            background-color: #5D6D7E; /* Ändrat till samma diskreta ton */
            color: white;
            border: none;
            border-radius: 0 6px 6px 0;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .add-custom-intervention button:hover {
            background-color: #34495E; /* Ändrat till mörkare diskret ton vid hover */
        }
        
        /* No results message */
        .no-results {
            padding: 10px;
            text-align: center;
            color: #666;
            font-style: italic;
            display: none;
        }
        
        /* Drag and drop styles for risk cells */
        .no-risk, .at-risk, .high-risk {
            position: relative;
            transition: background-color 0.2s ease;
        }
        
        .container-drag-over {
            background-color: rgba(93, 109, 126, 0.1) !important;
            border: 2px dashed #5D6D7E !important;
            border-radius: 6px;
            padding: 10px;
            min-height: 60px;
            animation: pulse 1.5s infinite;
        }
        
        .item.dragging {
            background-color: rgba(0, 123, 255, 0.1) !important;
            opacity: 0.8;
            cursor: move;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        .item.drag-over {
            position: relative;
        }
        
        .item.drag-over::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: -2px;
            height: 4px;
            background-color: #0d6efd;
            z-index: 100;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        /* Intervention in risk cell styles */
        .item[data-item-id^="intervention_"] {
            background-color: #f8f9fa;
            border-left: 3px solid #5D6D7E;
        }
        
        .item[data-item-id^="intervention_"] .item-content {
            display: flex;
            align-items: center;
        }
        
        .item[data-item-id^="intervention_"]:hover {
            background-color: #EBF0F5;
        }

        /* För att positionera ikoner i tips */
        .tip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            margin-right: 6px;
            vertical-align: middle;
        }

        /* Justera drag-hint-navigation för att bättre passa större ruta */
        .drag-hint-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
        }

        /* Ensure copy button is properly styled */
        .copy-btn {
            background: transparent;
            border: none;
            color: #5D6D7E;
            cursor: pointer;
            margin-left: 5px;
            padding: 3px 6px;
            border-radius: 3px;
        }
        
        .copy-btn:hover {
            background-color: rgba(93, 109, 126, 0.1);
        }
    </style>
</head>
<body class="luxury-dashboard">
    <div class="header">
        <h2>SENTION</h2>
        <div class="navbar-links">
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='anstalld') }}" class="{{ 'active' if current_category == 'anstalld' else '' }}">
                    Anställd
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-person"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information relaterad till individuella medarbetare och deras specifika hälsosituationer
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='grupp') }}" class="{{ 'active' if current_category == 'grupp' else '' }}">
                    Grupp
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-people"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information relaterad till arbetsgrupper och deras gemensamma hälsostatus
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='organisation') }}" class="{{ 'active' if current_category == 'organisation' else '' }}">
                    Organisation
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-building"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar övergripande information för hela organisationen och dess hälsosituation
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='foretagsledning') }}" class="{{ 'active' if current_category == 'foretagsledning' else '' }}">
                    Företagsledning
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-briefcase"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information specifikt relaterad till företagets ledningsgrupp
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='managers') }}" class="{{ 'active' if current_category == 'managers' else '' }}">
                    Managers
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-person-badge"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information relaterad till chefer
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='supervisors') }}" class="{{ 'active' if current_category == 'supervisors' else '' }}">
                    Supervisors
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-person-check"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar information relaterad till handledare
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('home', category='system') }}" class="{{ 'active' if current_category == 'system' else '' }}">
                    System
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-gear"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar systemrelaterad information och inställningar
                    </div>
                </div>
            </div>
            
            <div class="info-tooltip">
                <a href="{{ url_for('dashboard') }}" class="{{ 'active' if current_category == 'dashboard' else '' }}">
                    Dashboard
                </a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-speedometer2"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Visar sammanfattande information och insikter från alla sektioner
                    </div>
                </div>
            </div>
        </div>
        <div class="nav-buttons">
            <div class="info-tooltip">
                <a href="{{ url_for('profile') }}" class="profile-btn"><i class="bi bi-person"></i> Min profil</a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-person"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Hantera din användarprofil och personliga inställningar
                    </div>
                </div>
            </div>
            
            {% if session.role == 'admin' %}
            <div class="info-tooltip">
                <a href="{{ url_for('admin_users') }}" class="admin-btn"><i class="bi bi-gear"></i> Användarhantering</a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-gear"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Administrera användare, behörigheter och systemfunktioner
                    </div>
                </div>
            </div>
            {% endif %}
            
            <div class="info-tooltip">
                <a href="{{ url_for('logout') }}" class="logout-btn"><i class="bi bi-box-arrow-right"></i> Logga ut</a>
                <div class="info-tooltip-content">
                    <div class="info-icon">
                        <i class="bi bi-box-arrow-right"></i>
                    </div>
                    <div class="info-tooltip-text">
                        Logga ut från systemet och avsluta din session
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main content rows -->
    <div class="entity-row" data-category="{{ current_category }}">
        <div class="entity-title">HR</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>🟢 Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>🟡 Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>🔴 Hög risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">➕ Rätt riskgrupp i rätt tid</div>
            <div class="indicator">➕➕ Används i önskad utsträckning</div>
            <div class="indicator">➕➕➕ Har avsedd effekt</div>
        </div>
    </div>

    <!-- Company Health Row -->
    <div class="entity-row" data-category="{{ current_category }}">
        <div class="entity-title">Företagshälsovård</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>🟢 Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Företagshälsovård', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>🟡 Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Företagshälsovård', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>🔴 Hög risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Företagshälsovård', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">➕ Rätt riskgrupp i rätt tid</div>
            <div class="indicator">➕➕ Används i önskad utsträckning</div>
            <div class="indicator">➕➕➕ Har avsedd effekt</div>
        </div>
    </div>

    <!-- Other Providers Row -->
    <div class="entity-row" data-category="{{ current_category }}">
        <div class="entity-title">Andra leverantörer</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>🟢 Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Andra leverantörer', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>🟡 Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Andra leverantörer', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>🔴 Hög risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Andra leverantörer', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">➕ Rätt riskgrupp i rätt tid</div>
            <div class="indicator">➕➕ Används i önskad utsträckning</div>
            <div class="indicator">➕➕➕ Har avsedd effekt</div>
        </div>
    </div>

    <!-- Status message and auto-save indicator -->
    <div class="container">
        <div id="auto-save-indicator" class="auto-save-indicator"></div>
        <div id="status-message" class="status-message"></div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div id="delete-confirm-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal" onclick="closeDeleteModal()">&times;</span>
            <h4>Bekräfta borttagning</h4>
            <p>Är du säker på att du vill ta bort detta objekt?</p>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeDeleteModal()">Avbryt</button>
                <button class="btn btn-danger" onclick="confirmDelete()">Ta bort</button>
            </div>
        </div>
    </div>
    
    <!-- Drag hint for first-time users -->
    <div id="drag-hint" class="drag-hint" style="display: none;">
        <span class="drag-hint-close" onclick="closeDragHint()">✕</span>
        <h4 style="margin-top: 0; color: #0d6efd;"><i class="bi bi-lightbulb"></i> Tips &amp; Hjälp</h4>
        <div class="drag-hint-content">
            <span id="drag-hint-text">Du kan dra i cellen för att ändra ordning på objekten</span>
            <div class="tip-navigation">
                <button class="tip-nav-btn" onclick="previousTip()"><i class="bi bi-chevron-left"></i></button>
                <span class="tip-counter"><span id="current-tip">1</span>/<span id="total-tips">6</span></span>
                <button class="tip-nav-btn" onclick="nextTip()"><i class="bi bi-chevron-right"></i></button>
            </div>
        </div>
    </div>
    
    <!-- Help floating button -->
    <div id="help-floating-btn" class="help-floating-btn visible" onclick="showDragHint(true)">
        <i class="bi bi-lightbulb"></i>
    </div>
    
    <!-- Keyboard shortcuts modal -->
    <div id="shortcuts-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal" onclick="closeShortcutsModal()">&times;</span>
            <h3>Tangentbordsgenvägar</h3>
            <table class="shortcuts-table">
                <tr>
                    <td><kbd>Enter</kbd></td>
                    <td>Avsluta redigering och spara</td>
                </tr>
                <tr>
                    <td><kbd>Esc</kbd></td>
                    <td>Avbryt redigering</td>
                </tr>
                <tr>
                    <td><kbd>Tab</kbd></td>
                    <td>Gå till nästa objekt</td>
                </tr>
                <tr>
                    <td><kbd>Shift</kbd> + <kbd>Tab</kbd></td>
                    <td>Gå till föregående objekt</td>
                </tr>
                <tr>
                    <td><kbd>Ctrl</kbd> + <kbd>S</kbd></td>
                    <td>Spara alla ändringar manuellt</td>
                </tr>
                <tr>
                    <td><kbd>Ctrl</kbd> + <kbd>N</kbd></td>
                    <td>Lägg till nytt objekt</td>
                </tr>
                <tr>
                    <td><kbd>Delete</kbd></td>
                    <td>Ta bort markerat objekt</td>
                </tr>
                <tr>
                    <td><kbd>?</kbd></td>
                    <td>Visa denna hjälp</td>
                </tr>
            </table>
        </div>
    </div>
    
    <!-- Welcome tutorial modal -->
    <div id="welcome-modal" class="modal" style="display: none;">
        <div class="modal-content welcome-content">
            <span class="close-modal" onclick="closeWelcomeModal()">&times;</span>
            <h3>Välkommen till SENTION Kartläggning!</h3>
            <div class="welcome-steps">
                <div class="welcome-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Lägg till objekt</h4>
                        <p>Klicka på <strong>+</strong> knappen i respektive kolumn för att lägga till ett nytt objekt.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Redigera text</h4>
                        <p>Klicka på texten för att redigera den. Tryck <kbd>Enter</kbd> när du är klar.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Sätt betyg</h4>
                        <p>Klicka på betygsområdet för att välja ett betyg från listan.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Ändra ordning</h4>
                        <p>Dra i handtaget <i class="bi bi-grip-vertical"></i> för att ändra ordning på objekten. Håll muspekaren över handtaget tills den visar ett <strong>grab</strong>-ikon och dra sedan objektet till önskad position.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h4>Flytta till annan risknivå</h4>
                        <p>Du kan dra objekt mellan de olika riskkolumnerna (🟢, 🟡, 🔴) för att ändra risknivå. Använd samma draghandtag <i class="bi bi-grip-vertical"></i> för denna funktion.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">6</div>
                    <div class="step-content">
                        <h4>Automatisk sparning</h4>
                        <p>Alla ändringar sparas automatiskt. Du kan se status i botten av sidan.</p>
                    </div>
                </div>
            </div>
            <div class="welcome-footer">
                <button class="welcome-btn" onclick="closeWelcomeModal()">Kom igång</button>
                <label class="dont-show-again">
                    <input type="checkbox" id="dont-show-welcome" onchange="updateWelcomePreference()">
                    Visa inte igen
                </label>
            </div>
        </div>
    </div>

    <!-- Rating selector popup -->
    <div id="rating-selector" class="rating-selector">
        <div class="rating-option" onclick="selectRating('➕')">➕ Rätt riskgrupp i rätt tid</div>
        <div class="rating-option" onclick="selectRating('➕➕')">➕➕ Används i önskad utsträckning</div>
        <div class="rating-option" onclick="selectRating('➕➕➕')">➕➕➕ Har avsedd effekt</div>
        <div class="rating-option" onclick="selectRating('')">Ingen bedömning</div>
    </div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = '{{ supabase_url }}';
        const supabaseKey = '{{ supabase_key }}';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
        const currentCategory = "{{ current_category }}";
        
        // Auto-save variables
        let saveTimeout = null;
        const saveDelay = 1000; // 1 second delay before saving
        
        // Current cell being rated
        let currentRatingCell = null;
        
        // Track currently editing cell
        let currentlyEditingCell = null;
        let isCurrentlySaving = false;
        
        // Track cells being edited by other users
        const cellsBeingEditedByOthers = new Map(); // Map of "entityId-riskLevel-itemId" to user ID
        
        // Generate a unique user ID for this session
        const sessionUserId = generateUUID();
        
        // Drag and drop variables
        let draggedItem = null;
        let isDragging = false;

        // Setup for drag and drop
        document.addEventListener('mouseup', function() {
            // Reset dragging state when mouse is released
            isDragging = false;
            // Reset draggable attributes after a short delay to prevent issues
            setTimeout(() => {
                if (!isDragging && draggedItem) {
                    draggedItem.setAttribute('draggable', 'false');
                    draggedItem = null;
                }
            }, 100);
        });
        
        // Set up Supabase realtime subscription
        function setupRealtimeSubscription() {
            console.log("Setting up realtime subscription...");
            
            // Subscribe to changes in the items table
            const channel = supabaseClient.channel('items_changes')
                .on(
                    'postgres_changes',
                    {
                        event: '*', // Listen for all events (INSERT, UPDATE, DELETE)
                    schema: 'public',
                        table: 'items'
                    },
                    (payload) => {
                        console.log('Change received!', payload);
                        // Only reload if we're not currently saving
                        if (!isCurrentlySaving) {
                    handleRealtimeChange(payload);
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Subscription status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('Successfully subscribed to realtime changes!');
                    }
                });
                
            // Also subscribe to the editing status channel
            const editingChannel = supabaseClient.channel('editing_status')
                .on(
                    'broadcast',
                    { event: 'editing' },
                    (payload) => {
                        handleEditingStatus(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'rating_change' },
                    (payload) => {
                        handleRatingChange(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'item_deletion' },
                    (payload) => {
                        handleItemDeletion(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'new_item' },
                    (payload) => {
                        handleNewItem(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'item_move' },
                    (payload) => {
                        handleItemMove(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'item_reorder' },
                    (payload) => {
                        handleItemReorder(payload);
                    }
                )
                .subscribe();
                
            // Set up a heartbeat to keep editing status alive
            setInterval(() => {
                if (currentlyEditingCell) {
                    // Re-broadcast our editing status every 5 seconds to keep it alive
                    broadcastEditingStatus(currentlyEditingCell, true);
                }
            }, 5000);
            
            return [channel, editingChannel];
        }
        
        // Handle realtime changes
        function handleRealtimeChange(payload) {
            console.log('Handling realtime change:', payload);
            
            // Don't reload if we're currently editing a cell
            if (currentlyEditingCell) {
                console.log('Not reloading because user is editing a cell');
                return;
            }
            
            // Instead of reloading the entire page, fetch only the updated data
            fetch(`/get_items?category=${currentCategory}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Sort items by position before updating DOM
                        data.items.sort((a, b) => {
                            // First group by entity and risk_level
                            if (a.entity !== b.entity) return a.entity.localeCompare(b.entity);
                            if (a.risk_level !== b.risk_level) return a.risk_level.localeCompare(b.risk_level);
                            // Then sort by position
                            return a.position - b.position;
                        });
                        
                        // Update the DOM with the sorted items
                        updateItemsInDOM(data.items);
                        
                        // Show a subtle notification that content was updated
                        const autoSaveIndicator = document.getElementById('auto-save-indicator');
                        autoSaveIndicator.innerHTML = 'Innehåll uppdaterat';
                        setTimeout(() => {
                            autoSaveIndicator.innerHTML = '';
                        }, 2000);
                    } else {
                        console.error('Error fetching updated items:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error fetching updated items:', error);
                });
        }
        
        // Function to update items in the DOM without reloading the page
        function updateItemsInDOM(items) {
            console.log('Updating items in DOM with server data');
            
            // Create a map of existing items for quick lookup
            const existingItemsMap = new Map();
            document.querySelectorAll('.item').forEach(item => {
                const itemId = item.getAttribute('data-item-id');
                existingItemsMap.set(itemId, item);
            });
            
            // Create a map of updated items
            const updatedItemsMap = new Map();
            items.forEach(item => {
                if (item.category === currentCategory) {
                    updatedItemsMap.set(item.id, item);
                }
            });
            
            // First pass: Update or add items
            items.forEach(item => {
                if (item.category === currentCategory) {
                    const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
                    
                    // Skip if this item is currently being edited
                    if (existingItem && (existingItem.querySelector('.cell-editing') || existingItem.querySelector('.cell-editing-other'))) {
                        return;
                    }
                    
                    // Find the correct container
                    const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
            
                    if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                
                        if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                    
                            if (existingItem) {
                                // Check if the item needs to be moved to a different container
                                const currentContainer = existingItem.parentNode;
                                const currentRiskLevel = existingItem.getAttribute('data-risk');
                                
                                if (currentRiskLevel !== item.risk_level) {
                                    // Item has moved to a different risk level
                                    existingItem.remove();
                                    existingItem.setAttribute('data-risk', item.risk_level);
                                    
                                    // Add to new container at the correct position
                                    if (item.position === 0) {
                                        // Special case for position 0
                                        container.insertBefore(existingItem, container.firstChild);
                                    } else if (container.children.length > item.position) {
                                        container.insertBefore(existingItem, container.children[item.position]);
                                    } else {
                                        container.appendChild(existingItem);
                                    }
                                    
                                    // Store position for verification
                                    existingItem.setAttribute('data-position', item.position.toString());
                                } else if (currentContainer === container) {
                                    // Item is in the correct container, but might need reordering
                                    const currentIndex = Array.from(container.children).indexOf(existingItem);
                                    if (currentIndex !== item.position) {
                                        // Remove and reinsert at the correct position
                                        existingItem.remove();
                                        
                                        if (item.position === 0) {
                                            // Special case for position 0
                                            container.insertBefore(existingItem, container.firstChild);
                                        } else if (container.children.length > item.position) {
                                            container.insertBefore(existingItem, container.children[item.position]);
                                        } else {
                                            container.appendChild(existingItem);
                                        }
                                        
                                        // Store position for verification
                                        existingItem.setAttribute('data-position', item.position.toString());
                                    }
                                }
                                
                                // Update content
                                const textElement = existingItem.querySelector('.item-text');
                                const ratingElement = existingItem.querySelector('.item-rating');
                                
                                // Only update if not being edited
                                if (!textElement.classList.contains('cell-editing') && !textElement.classList.contains('cell-editing-other')) {
                                    textElement.textContent = item.text;
                                }
                                
                                ratingElement.textContent = item.rating || '';
                            } else {
                                // Create new item
                                const itemElement = document.createElement('div');
                                itemElement.className = 'item';
                                itemElement.setAttribute('draggable', 'false');
                                itemElement.setAttribute('data-entity', item.entity);
                                itemElement.setAttribute('data-risk', item.risk_level);
                                itemElement.setAttribute('data-item-id', item.id || generateUUID());
                                itemElement.setAttribute('data-position', item.position.toString());
                                itemElement.setAttribute('data-category', item.category);
                                
                                // Use empty string if rating is null, undefined, or empty
                                const ratingValue = item.rating || '';
                                
                                itemElement.innerHTML = `
                                    <i class="bi bi-grip-vertical drag-handle" title="Dra för att ändra ordning"></i>
                                    <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text}</div>
                                    <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                                    <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                                `;
                                
                                // Add to container at the correct position
                                if (item.position === 0) {
                                    // Special case for position 0
                                    container.insertBefore(itemElement, container.firstChild);
                                } else if (container.children.length > item.position) {
                                    container.insertBefore(itemElement, container.children[item.position]);
                                } else {
                                    container.appendChild(itemElement);
                                }
                                
                                // Add click handler to make text editable when clicked
                                const textElement = itemElement.querySelector('.item-text');
                                textElement.addEventListener('click', function(e) {
                                    // Prevent editing if cell is being edited by another user
                                    if (textElement.classList.contains('cell-editing-other')) {
                                        e.preventDefault();
                                        return;
                                    }
                                    
                                    if (textElement.getAttribute('contenteditable') === 'false') {
                                        textElement.setAttribute('contenteditable', 'true');
                                        textElement.focus();
                                    }
                                });
                                
                                // Initialize drag and drop for this item
                                initializeDragForItem(itemElement);
                            }
                        }
                    }
                }
            });
            
            // Second pass: Remove items that no longer exist in the updated data
            existingItemsMap.forEach((itemElement, itemId) => {
                // Skip if this item is currently being edited
                if (itemElement.querySelector('.cell-editing') || itemElement.querySelector('.cell-editing-other')) {
                    return;
                }
                
                // If the item doesn't exist in the updated data, remove it
                if (!updatedItemsMap.has(itemId)) {
                    itemElement.remove();
                }
            });
            
            // Re-apply editing indicators
            applyEditingIndicators();
            
            // Verification step: check if all items are in their expected positions
            let hasPositionMismatch = false;
            document.querySelectorAll('.item').forEach(item => {
                const expectedPosition = parseInt(item.getAttribute('data-position'), 10);
                if (!isNaN(expectedPosition)) {
                    const container = item.parentNode;
                    const actualPosition = Array.from(container.children).indexOf(item);
                    if (expectedPosition !== actualPosition) {
                        console.warn(`Position mismatch for item ${item.getAttribute('data-item-id')}: expected ${expectedPosition}, got ${actualPosition}`);
                        hasPositionMismatch = true;
                    }
                }
            });
            
            if (hasPositionMismatch) {
                console.warn('Position mismatches detected. Consider refreshing to ensure correct positioning.');
            }
        }
        
        // Handle editing status updates
        function handleEditingStatus(payload) {
            console.log('Editing status update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { userId, entityId, riskLevel, itemId, isEditing, newText } = payload.payload;
            const cellKey = `${entityId}-${riskLevel}-${itemId}`;
            
            // Find the cell
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                const textCell = item.querySelector('.item-text');
                
                if (isEditing) {
                    // Another user is editing this cell
                    textCell.classList.add('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Prevent editing
                    
                    // Remove any click handlers that might enable editing
                    const newTextCell = textCell.cloneNode(true);
                    textCell.parentNode.replaceChild(newTextCell, textCell);
                    
                    // Store in our map of cells being edited
                    cellsBeingEditedByOthers.set(cellKey, userId);
                } else {
                    // User stopped editing
                    textCell.classList.remove('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Keep it non-editable by default
                    
                    // If we received new text, update the cell content
                    if (newText !== undefined) {
                        textCell.textContent = newText;
                    }
                    
                    // Add click handler to make it editable again when clicked
                    const newTextCell = textCell.cloneNode(true);
                    newTextCell.addEventListener('click', function(e) {
                        // Prevent editing if cell is being edited by another user
                        if (newTextCell.classList.contains('cell-editing-other')) {
                            e.preventDefault();
                            return;
                        }
                        
                        if (newTextCell.getAttribute('contenteditable') === 'false') {
                            newTextCell.setAttribute('contenteditable', 'true');
                            newTextCell.focus();
                        }
                    });
                    textCell.parentNode.replaceChild(newTextCell, textCell);
                    
                    // Remove from our map
                    cellsBeingEditedByOthers.delete(cellKey);
                    
                    // Show a subtle notification that content was updated
                    const autoSaveIndicator = document.getElementById('auto-save-indicator');
                    autoSaveIndicator.innerHTML = 'Innehåll uppdaterat';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            }
        }
        
        // Handle rating change
        function handleRatingChange(payload) {
            console.log('Rating change update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId, rating } = payload.payload;
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                const ratingCell = item.querySelector('.item-rating');
                
                // Update the rating
                ratingCell.textContent = rating;
                
                // Show a subtle notification that content was updated
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Betyg uppdaterat';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Handle item deletion
        function handleItemDeletion(payload) {
            console.log('Item deletion update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId } = payload.payload;
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                // Remove the item from DOM
                item.remove();
                
                // Show a subtle notification that content was updated
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Objekt borttaget';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Broadcast editing status
        function broadcastEditingStatus(cell, isEditing) {
            // Find item and get its data attributes
            const item = cell.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Include the new text when stopping editing
            const newText = isEditing ? undefined : cell.textContent;
            
            // Broadcast editing status
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'editing',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    isEditing,
                    newText
                }
            });
        }
        
        // Apply editing indicators for cells being edited by others
        function applyEditingIndicators() {
            // Clear all existing indicators first
            document.querySelectorAll('.cell-editing-other').forEach(cell => {
                cell.classList.remove('cell-editing-other');
                cell.setAttribute('contenteditable', 'false');
                
                // Add click handler to make it editable again when clicked
                cell.addEventListener('click', function(e) {
                    // Prevent editing if cell is being edited by another user
                    if (cell.classList.contains('cell-editing-other')) {
                        e.preventDefault();
                        return;
                    }
                    
                    if (cell.getAttribute('contenteditable') === 'false') {
                        cell.setAttribute('contenteditable', 'true');
                        cell.focus();
                    }
                });
            });
            
            // Apply indicators for cells being edited by others
            cellsBeingEditedByOthers.forEach((userId, cellKey) => {
                const [entityId, riskLevel, itemId] = cellKey.split('-');
                
                const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
                if (item) {
                    const textCell = item.querySelector('.item-text');
                    textCell.classList.add('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Prevent editing
                }
            });
        }

        // Generate UUID for session
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Function to add new item
        function addNewItem(button, entity, riskLevel) {
            const column = button.closest('.risk-column');
            const container = column.querySelector('.items-container');
            
            // Generate a unique ID for this item
            const itemId = generateUUID();
            
            // Create new item
            const item = document.createElement('div');
            item.className = 'item';
            item.setAttribute('draggable', 'false'); // Initially not draggable, only becomes draggable when hovering over drag handle
            item.setAttribute('data-entity', entity);
            item.setAttribute('data-risk', riskLevel);
            item.setAttribute('data-item-id', itemId);
            item.setAttribute('data-category', currentCategory); // Set the current category
            item.innerHTML = `
                <i class="bi bi-grip-vertical drag-handle" title="Dra för att ändra ordning"></i>
                <div class="item-text" contenteditable="true" data-placeholder="Skriv text här" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)"></div>
                <div class="item-rating" onclick="showRatingSelector(this)"></div>
                <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
            `;
            
            // Add to container
            container.insertBefore(item, container.firstChild);
            
            // Focus on the text element
            const textElement = item.querySelector('.item-text');
            
            // Auto-fill with last copied text if available
            if (window.lastCopiedText) {
                textElement.textContent = window.lastCopiedText;
                
                // Clear the last copied text so it's only used once
                window.lastCopiedText = "";
                
                // Save the changes
                setTimeout(() => {
                    handleCellChange(textElement);
                }, 100);
                
                // Show notification
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                if (autoSaveIndicator) {
                    autoSaveIndicator.innerHTML = 'Intervention tillagd';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            } else {
                // Focus the element if there's no text to auto-fill
                textElement.focus();
            }
            
            // Add click handler to make text editable when clicked
            textElement.addEventListener('blur', function() {
                // After the initial edit, set contenteditable to false
                textElement.setAttribute('contenteditable', 'false');
                
                // Add click handler to make it editable again when clicked
                textElement.addEventListener('click', function(e) {
                    // Prevent editing if cell is being edited by another user
                    if (textElement.classList.contains('cell-editing-other')) {
                        e.preventDefault();
                        return;
                    }
                    
                    if (textElement.getAttribute('contenteditable') === 'false') {
                        textElement.setAttribute('contenteditable', 'true');
                        textElement.focus();
                    }
                });
            });
            
            // Add drag and drop event listeners
            initializeDragForItem(item);
            
            // Broadcast the new item to other users
            broadcastNewItem(entity, riskLevel, itemId);
            
            // Trigger auto-save
            triggerAutoSave();
        }

        // Broadcast new item
        function broadcastNewItem(entity, riskLevel, itemId) {
            // Get the position of the new item (should be 0 for top position)
            const position = 0; // New items are added at the top by default
            
            // Broadcast new item creation
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'new_item',
                payload: {
                    userId: sessionUserId,
                    entityId: entity,
                    riskLevel: riskLevel,
                    itemId: itemId,
                    position: position,
                    category: currentCategory // Add category to payload
                }
            });
        }

        // Function to handle cell focus
        function handleCellFocus(cell) {
            // Mark this cell as being edited
            currentlyEditingCell = cell;
            cell.classList.add('cell-editing');
            
            // Broadcast editing status
            broadcastEditingStatus(cell, true);
        }
        
        // Function to handle cell changes
        function handleCellChange(cell) {
            // Get the new text content
            const newText = cell.textContent.trim();
            
            // Remove editing indicator
            cell.classList.remove('cell-editing');
            
            // Broadcast that we stopped editing, including the new text
            broadcastEditingStatus(cell, false);
            
            // Clear currently editing cell if it's this one
            if (currentlyEditingCell === cell) {
                currentlyEditingCell = null;
                
                // Show rating selector automatically after editing
                const item = cell.closest('.item');
                const ratingCell = item.querySelector('.item-rating');
                showRatingSelector(ratingCell);
            }
            
            // Trigger auto-save
            triggerAutoSave();
        }

        // Function to show rating selector
        function showRatingSelector(cell) {
            // Store reference to current cell
            currentRatingCell = cell;
            
            // Get rating selector
            const selector = document.getElementById('rating-selector');
            
            // Position selector near the cell
            const rect = cell.getBoundingClientRect();
            selector.style.top = (rect.bottom + window.scrollY) + 'px';
            selector.style.left = rect.left + 'px';
            
            // Show selector
            selector.style.display = 'block';
            
            // Highlight the first option by default
            const options = selector.querySelectorAll('.rating-option');
            if (options.length > 0) {
                options.forEach(opt => opt.classList.remove('highlighted'));
                options[0].classList.add('highlighted');
                
                // Set focus to the selector for keyboard navigation
                selector.setAttribute('tabindex', '-1');
                selector.focus();
            }
            
            // Add event listener to close selector when clicking outside
            document.addEventListener('click', closeRatingSelectorOutside);
            
            // Add keyboard event listener for rating selector navigation
            document.addEventListener('keydown', handleRatingSelectorKeyboard);
        }
        
        // Function to handle keyboard navigation in rating selector
        function handleRatingSelectorKeyboard(e) {
            const selector = document.getElementById('rating-selector');
            
            // Only handle if selector is visible
            if (selector.style.display !== 'block') {
                document.removeEventListener('keydown', handleRatingSelectorKeyboard);
                return;
            }
            
            const options = selector.querySelectorAll('.rating-option');
            const highlightedOption = selector.querySelector('.rating-option.highlighted');
            let currentIndex = -1;
            
            // Find current highlighted index
            if (highlightedOption) {
                currentIndex = Array.from(options).indexOf(highlightedOption);
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    // Move to next option
                    if (currentIndex < options.length - 1) {
                        options.forEach(opt => opt.classList.remove('highlighted'));
                        options[currentIndex + 1].classList.add('highlighted');
                        options[currentIndex + 1].scrollIntoView({ block: 'nearest' });
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    // Move to previous option
                    if (currentIndex > 0) {
                        options.forEach(opt => opt.classList.remove('highlighted'));
                        options[currentIndex - 1].classList.add('highlighted');
                        options[currentIndex - 1].scrollIntoView({ block: 'nearest' });
                    }
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    // Select highlighted option
                    if (highlightedOption) {
                        highlightedOption.click();
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    // Close selector
                    selector.style.display = 'none';
                    document.removeEventListener('click', closeRatingSelectorOutside);
                    document.removeEventListener('keydown', handleRatingSelectorKeyboard);
                    break;
                    
                case 'Tab':
                    e.preventDefault();
                    // Move to next option or close if at last option
                    if (currentIndex < options.length - 1) {
                        options.forEach(opt => opt.classList.remove('highlighted'));
                        options[currentIndex + 1].classList.add('highlighted');
                        options[currentIndex + 1].scrollIntoView({ block: 'nearest' });
                    } else {
                        // At last option, close and move to next element
                        selector.style.display = 'none';
                        document.removeEventListener('click', closeRatingSelectorOutside);
                        document.removeEventListener('keydown', handleRatingSelectorKeyboard);
                    }
                    break;
            }
        }

        // Function to close rating selector when clicking outside
        function closeRatingSelectorOutside(event) {
            const selector = document.getElementById('rating-selector');
            
            // Check if click is outside the selector and not on a rating cell
            if (!selector.contains(event.target) && 
                !event.target.classList.contains('item-rating')) {
                selector.style.display = 'none';
                document.removeEventListener('click', closeRatingSelectorOutside);
                document.removeEventListener('keydown', handleRatingSelectorKeyboard);
            }
        }
        
        // Function to select a rating
        function selectRating(rating) {
            if (currentRatingCell) {
                currentRatingCell.textContent = rating;
                
                // Hide selector
                document.getElementById('rating-selector').style.display = 'none';
                document.removeEventListener('click', closeRatingSelectorOutside);
                document.removeEventListener('keydown', handleRatingSelectorKeyboard);
                
                // Broadcast the rating change to other users
                broadcastRatingChange(currentRatingCell, rating);
                
                // Trigger auto-save
                triggerAutoSave();
            }
        }
        
        // Broadcast rating change
        function broadcastRatingChange(cell, rating) {
            // Find item and get its data attributes
            const item = cell.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Broadcast rating change
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'rating_change',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    rating
                }
            });
        }
        
        // Variables for delete confirmation
        let itemToDelete = null;
        
        // Function to show delete confirmation modal
        function showDeleteModal(button) {
            itemToDelete = button;
            document.getElementById('delete-confirm-modal').style.display = 'flex';
        }
        
        // Function to close delete confirmation modal
        function closeDeleteModal() {
            document.getElementById('delete-confirm-modal').style.display = 'none';
            itemToDelete = null;
        }
        
        // Function to confirm delete
        function confirmDelete() {
            if (itemToDelete) {
                const item = itemToDelete.closest('.item');
                const entityId = item.getAttribute('data-entity');
                const riskLevel = item.getAttribute('data-risk');
                const itemId = item.getAttribute('data-item-id');
                
                // Remove the item from DOM
                item.remove();
                
                // Broadcast the deletion to other users
                broadcastItemDeletion(entityId, riskLevel, itemId);
                
                // Trigger auto-save
                triggerAutoSave();
                
                // Close the modal
                closeDeleteModal();
            }
        }
        
        // Function to delete item
        function deleteItem(button) {
            showDeleteModal(button);
        }
        
        // Broadcast item deletion
        function broadcastItemDeletion(entityId, riskLevel, itemId) {
            // Broadcast deletion
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'item_deletion',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId
                }
            });
        }
        
        // Function to trigger auto-save with debounce
        function triggerAutoSave() {
            // Show saving indicator
            const autoSaveIndicator = document.getElementById('auto-save-indicator');
            autoSaveIndicator.innerHTML = '<span class="saving">Sparar...</span>';
            
            // Clear previous timeout
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            // Set new timeout
            saveTimeout = setTimeout(() => {
                saveDataToSupabase();
            }, saveDelay);
        }
        
        // Function to show status message
        function showStatusMessage(message, isSuccess) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = message;
            statusMessage.className = 'status-message';
            
            if (isSuccess) {
                statusMessage.classList.add('success-message');
            } else {
                statusMessage.classList.add('error-message');
            }
            
            statusMessage.style.display = 'block';
            
            // Hide message after 5 seconds
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }
        
        // Function to collect all items data
        function collectItemsData() {
            const items = [];
            
            // Get all entity rows
            const entityRows = document.querySelectorAll('.entity-row');
            
            entityRows.forEach(entityRow => {
                const entity = entityRow.querySelector('.entity-title').textContent;
                
                // Get all risk columns in this entity row
                const riskColumns = entityRow.querySelectorAll('.risk-column');
                
                riskColumns.forEach(column => {
                    // Determine risk level
                    let riskLevel = 'Unknown';
                    if (column.classList.contains('no-risk')) riskLevel = 'No';
                    if (column.classList.contains('at-risk')) riskLevel = 'At';
                    if (column.classList.contains('high-risk')) riskLevel = 'High';
                    
                    // Get all items in this column
                    const itemElements = column.querySelectorAll('.item');
                    
                    // Update position attributes in DOM to match actual positions
                    Array.from(itemElements).forEach((item, index) => {
                        item.setAttribute('data-position', index.toString());
                    });
                    
                    itemElements.forEach((item, index) => {
                        const text = item.querySelector('.item-text').textContent.trim();
                        const rating = item.querySelector('.item-rating').textContent.trim();
                        
                        if (text) {
                            // Create item data with exact position
                            const itemData = {
                                text: text,
                                entity: entity,
                                risk_level: riskLevel,
                                category: currentCategory,
                                rating: rating,
                                position: index,
                                id: item.getAttribute('data-item-id')
                            };
                            
                            items.push(itemData);
                            
                            // Log each item's position for debugging
                            console.log(`Saving ${entity} - ${riskLevel} item at position ${index}: ${text.substring(0, 20)}...`);
                        }
                    });
                });
            });
            
            return items;
        }
        
        // Function to save data to Supabase
        async function saveDataToSupabase() {
            try {
                // Set flag that we're saving
                isCurrentlySaving = true;
                
                const itemsData = collectItemsData();
                
                // Use fetch to save data to the server
                const response = await fetch('/save_items', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                    body: JSON.stringify({
                        category: currentCategory,
                        items: itemsData
                    })
                });
                
                const data = await response.json();
                
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Error saving data');
                }
                
                // Update auto-save indicator
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Sparad';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
                
                // Reset saving flag
                isCurrentlySaving = false;
                
            } catch (error) {
                console.error('Error saving data:', error);
                
                // Update auto-save indicator
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Fel vid sparande';
                
                // Show error message
                showStatusMessage('Ett fel uppstod när data skulle sparas: ' + error.message, false);
                
                // Reset saving flag
                isCurrentlySaving = false;
            }
        }
        
        // Initialize drag and drop for an item
        function initializeDragForItem(item) {
            // Remove any existing event listeners first
            item.removeEventListener('dragstart', handleDragStart);
            item.removeEventListener('dragend', handleDragEnd);
            item.removeEventListener('dragover', handleDragOver);
            item.removeEventListener('drop', handleDrop);
            
            // Add event listeners
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('drop', handleDrop);
            
            // Ensure the drag handle is properly interactive
            const dragHandle = item.querySelector('.drag-handle');
            if (dragHandle) {
                dragHandle.addEventListener('mouseenter', function() {
                    item.setAttribute('draggable', 'true');
                    dragHandle.style.cursor = 'grab';
                });
                
                dragHandle.addEventListener('mouseleave', function() {
                    // Only set draggable to false if we're not currently dragging
                    if (!item.classList.contains('dragging')) {
                        item.setAttribute('draggable', 'false');
                    }
                });
                
                dragHandle.addEventListener('mousedown', function(e) {
                    // Store a reference to the item being dragged
                    draggedItem = item;
                    dragHandle.style.cursor = 'grabbing';
                });
                
                dragHandle.addEventListener('mouseup', function() {
                    dragHandle.style.cursor = 'grab';
                });
            }
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            // Store a reference to the item being dragged
            draggedItem = this;
            isDragging = true;
            
            // Add a class to show it's being dragged
            this.classList.add('dragging');
            
            // Set the data being dragged
            // Get only the text content, excluding the rating
            const textOnly = this.querySelector('.item-text') ? 
                this.querySelector('.item-text').textContent : 
                this.textContent.replace('Kopiera', '').trim();
            
            e.dataTransfer.setData('text/plain', textOnly);
            
            // Set how it looks when dragged
            if (e.dataTransfer.setDragImage) {
                const dragIcon = document.createElement('div');
                dragIcon.textContent = textOnly;
                dragIcon.style.backgroundColor = '#5D6D7E';
                dragIcon.style.color = 'white';
                dragIcon.style.padding = '10px';
                dragIcon.style.borderRadius = '6px';
                dragIcon.style.position = 'absolute';
                dragIcon.style.top = '-1000px';
                document.body.appendChild(dragIcon);
                
                e.dataTransfer.setDragImage(dragIcon, 0, 0);
                
                // Remove the temporary element after a bit
                setTimeout(() => {
                    document.body.removeChild(dragIcon);
                }, 0);
            }
            
            // Listen for drag end
            this.addEventListener('dragend', function() {
                isDragging = false;
                
                this.classList.remove('dragging');
                
                // Reset draggable attribute after dragging
                setTimeout(() => {
                    this.setAttribute('draggable', 'false');
                }, 100);
                
                // Remove drag-over class from all items
                const items = document.querySelectorAll('.item');
                items.forEach(item => item.classList.remove('drag-over'));
                
                // Remove drag-over class from all containers
                const containers = document.querySelectorAll('.items-container');
                containers.forEach(container => container.classList.remove('container-drag-over'));
                
                // Also remove drag-over class from all risk cells
                const riskCells = document.querySelectorAll('.no-risk, .at-risk, .high-risk');
                riskCells.forEach(cell => {
                    cell.classList.remove('drag-over');
                });
                
                draggedItem = null;
            }, { once: true });
        }

        function handleDragEnd(e) {
            isDragging = false;
            
            this.classList.remove('dragging');
            
            // Reset draggable attribute after dragging
            setTimeout(() => {
                this.setAttribute('draggable', 'false');
            }, 100);
            
            // Remove drag-over class from all items
            const items = document.querySelectorAll('.item');
            items.forEach(item => item.classList.remove('drag-over'));
            
            // Remove drag-over class from all containers
            const containers = document.querySelectorAll('.items-container');
            containers.forEach(container => container.classList.remove('container-drag-over'));
            
            // Also remove drag-over class from all risk cells
            const riskCells = document.querySelectorAll('.no-risk, .at-risk, .high-risk');
            riskCells.forEach(cell => {
                cell.classList.remove('drag-over');
            });
            
            draggedItem = null;
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            
            // Don't allow dragging if any cell is being edited
            if (currentlyEditingCell) {
                return;
            }
            
            // Handle drag over items
            const item = e.target.closest('.item');
            if (item && item !== draggedItem) {
                // Remove drag-over class from all items
                const items = document.querySelectorAll('.item');
                items.forEach(i => i.classList.remove('drag-over'));
                
                // Get mouse position relative to the item
                const rect = item.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + (rect.height / 2);
                
                // Add drag-over class to the appropriate item
                if (mouseY < threshold) {
                    item.classList.add('drag-over');
                } else {
                    // If mouse is in bottom half, add class to next item if it exists
                    const nextItem = item.nextElementSibling;
                    if (nextItem) {
                        nextItem.classList.add('drag-over');
                    } else {
                        // If there's no next item, add class to current item
                        item.classList.add('drag-over');
                    }
                }
            }
            // Handle drag over empty containers
            else {
                const container = e.target.closest('.items-container');
                if (container) {
                    // Remove drag-over class from all containers
                    const containers = document.querySelectorAll('.items-container');
                    containers.forEach(c => c.classList.remove('container-drag-over'));
                    
                    // Add drag-over class to this container
                    container.classList.add('container-drag-over');
                }
            }
            
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            // Don't allow dropping if any cell is being edited
            if (currentlyEditingCell) {
                return;
            }
            
            // Make sure we have a valid dragged item
            if (!draggedItem) {
                console.log('No dragged item found');
                return false;
            }
            
            // Get original position and risk level before moving
            const originalRiskLevel = draggedItem.getAttribute('data-risk');
            const entityId = draggedItem.getAttribute('data-entity');
            const originalContainer = draggedItem.parentNode;
            // Get original position before any DOM changes
            const originalPosition = Array.from(originalContainer.children).indexOf(draggedItem);
            
            console.log(`Original position: ${originalPosition}, Risk level: ${originalRiskLevel}, Entity: ${entityId}`);
            
            // Handle drop on items
            const targetItem = e.target.closest('.item');
            if (targetItem && targetItem !== draggedItem) {
                // Get mouse position relative to the item
                const rect = targetItem.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + (rect.height / 2);
                
                // Remove drag-over class
                targetItem.classList.remove('drag-over');
                
                // Get the container
                const container = targetItem.parentNode;
                
                // Store current children before any DOM changes
                const oldChildren = Array.from(container.children);
                const targetIndex = oldChildren.indexOf(targetItem);
                
                // Store if we're in the same container (important for reordering logic)
                const sameContainer = (container === originalContainer);
                console.log(`Same container: ${sameContainer}, Target index: ${targetIndex}`);
                
                // Temporarily detach the dragged item to avoid position calculation issues
                draggedItem.remove();
                
                // Insert the item based on mouse position
                let newPosition;
                if (mouseY < threshold) {
                    // Insert before target item
                    container.insertBefore(draggedItem, targetItem);
                    newPosition = Array.from(container.children).indexOf(draggedItem);
                } else {
                    // Insert after target item
                    container.insertBefore(draggedItem, targetItem.nextSibling);
                    newPosition = Array.from(container.children).indexOf(draggedItem);
                }
                
                console.log(`New position: ${newPosition}`);
                
                // Get new risk level after moving
                const riskColumn = container.closest('.risk-column');
                let newRiskLevel = originalRiskLevel;
                if (riskColumn.classList.contains('no-risk')) newRiskLevel = 'No';
                if (riskColumn.classList.contains('at-risk')) newRiskLevel = 'At';
                if (riskColumn.classList.contains('high-risk')) newRiskLevel = 'High';
                
                // Update the risk level attribute if it changed
                if (newRiskLevel !== originalRiskLevel) {
                    console.log(`Risk level changed from ${originalRiskLevel} to ${newRiskLevel}`);
                    draggedItem.setAttribute('data-risk', newRiskLevel);
                    
                    // Broadcast the move to other users, including the position
                    broadcastItemMove(
                        entityId,
                        originalRiskLevel,
                        newRiskLevel,
                        draggedItem.getAttribute('data-item-id')
                    );
                } else {
                    // Store position in the item
                    draggedItem.setAttribute('data-position', newPosition.toString());
                    
                    // Broadcast position change within the same risk level
                    broadcastItemReorder(
                        entityId,
                        newRiskLevel,
                        draggedItem.getAttribute('data-item-id'),
                        newPosition
                    );
                }
                
                // Trigger auto-save to save the new order
                triggerAutoSave();
            }
            // Handle drop on empty containers
            else {
                const container = e.target.closest('.items-container');
                if (container) {
                    console.log('Dropping on container:', container);
                    
                    // Remove container drag-over class
                    container.classList.remove('container-drag-over');
                    
                    // Get new risk level
                    const riskColumn = container.closest('.risk-column');
                    let newRiskLevel = originalRiskLevel;
                    if (riskColumn.classList.contains('no-risk')) newRiskLevel = 'No';
                    if (riskColumn.classList.contains('at-risk')) newRiskLevel = 'At';
                    if (riskColumn.classList.contains('high-risk')) newRiskLevel = 'High';
                    console.log('New risk level:', newRiskLevel);
                    
                    // Store if we're in the same container (important for reordering logic)
                    const sameContainer = (container === originalContainer);
                    console.log(`Same container: ${sameContainer}`);
                    
                    // Temporarily detach the dragged item to avoid position calculation issues
                    draggedItem.remove();
                    
                    // If the drop is near the top of the container, insert at the beginning
                    const containerRect = container.getBoundingClientRect();
                    const mouseY = e.clientY;
                    const topThreshold = containerRect.top + 20; // 20px from top
                    
                    let newPosition;
                    if (mouseY < topThreshold && container.children.length > 0) {
                        // Drop at top of container
                        container.insertBefore(draggedItem, container.firstChild);
                    } else {
                        // Drop at end of container
                        container.appendChild(draggedItem);
                    }
                    
                    // Calculate the new position
                    newPosition = Array.from(container.children).indexOf(draggedItem);
                    console.log(`New position: ${newPosition}`);
                    
                    // Update the risk level attribute if it changed
                    if (newRiskLevel !== originalRiskLevel) {
                        console.log('Risk level changed, updating attribute and broadcasting');
                        draggedItem.setAttribute('data-risk', newRiskLevel);
                        
                        // Broadcast the move to other users
                        broadcastItemMove(
                            entityId,
                            originalRiskLevel,
                            newRiskLevel,
                            draggedItem.getAttribute('data-item-id')
                        );
                    } else {
                        // Store position in the item
                        draggedItem.setAttribute('data-position', newPosition.toString());
                        
                        // Broadcast position change
                        broadcastItemReorder(
                            entityId,
                            newRiskLevel,
                            draggedItem.getAttribute('data-item-id'),
                            newPosition
                        );
                    }
                    
                    // Trigger auto-save to save the new order and risk level
                    triggerAutoSave();
                }
            }
            
            return false;
        }

        // Broadcast item move between risk levels
        function broadcastItemMove(entityId, originalRiskLevel, newRiskLevel, itemId) {
            console.log('Broadcasting item move:', { entityId, originalRiskLevel, newRiskLevel, itemId });
            
            // Get the position within the new container
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${newRiskLevel}"][data-item-id="${itemId}"]`);
            const container = item.parentNode;
            
            // Calculate exact position
            const newPosition = Array.from(container.children).indexOf(item);
            console.log('Item moved to position:', newPosition);
            
            // Store the position in a data attribute for verification
            item.setAttribute('data-position', newPosition.toString());
            
            // Broadcast move with exact position information
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'item_move',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    originalRiskLevel,
                    newRiskLevel,
                    itemId,
                    newPosition
                }
            }).then(() => {
                console.log('Item move broadcast sent successfully with position:', newPosition);
            }).catch(error => {
                console.error('Error broadcasting item move:', error);
            });
        }

        // Handle item move between risk levels
        function handleItemMove(payload) {
            console.log('Item move update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, originalRiskLevel, newRiskLevel, itemId, newPosition } = payload.payload;
            console.log(`Moving item to position ${newPosition} in ${newRiskLevel} risk level`);
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${originalRiskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                // Find the entity row
                const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                    .find(row => row.querySelector('.entity-title').textContent === entityId);
                
                if (entityRow) {
                    // Find the target risk column
                    const riskColumn = entityRow.querySelector(
                        newRiskLevel === 'No' ? '.no-risk' :
                        newRiskLevel === 'At' ? '.at-risk' :
                        '.high-risk'
                    );
                    
                    if (riskColumn) {
                        // Find the target container
                        const targetContainer = riskColumn.querySelector('.items-container');
                        
                        // Update the risk level attribute
                        item.setAttribute('data-entity', entityId); // Ensure entity is correct
                        item.setAttribute('data-risk', newRiskLevel); // Update risk level
                        
                        // Add a subtle animation effect
                        item.style.transition = 'all 0.5s ease';
                        item.style.backgroundColor = 'rgba(13, 110, 253, 0.1)';
                        
                        // Remove the item from its current container
                        item.remove();
                        
                        // Get the existing items in the target container
                        const targetItems = Array.from(targetContainer.children);
                        
                        // Insert the item at the specified position - handle edge cases carefully
                        if (newPosition !== undefined) {
                            if (newPosition === 0) {
                                // Special case for position 0 (beginning of container)
                                targetContainer.insertBefore(item, targetContainer.firstChild);
                            } else if (newPosition < targetItems.length) {
                                // Insert at the specified position
                                targetContainer.insertBefore(item, targetItems[newPosition]);
                            } else {
                                // If position is at or beyond the end, append to the end
                                targetContainer.appendChild(item);
                            }
                            
                            // Store the position in a data attribute for verification
                            item.setAttribute('data-position', newPosition.toString());
                            
                            console.log(`Item moved to position ${newPosition} in container`);
                        } else {
                            // Fallback: append to the end if no position specified
                            targetContainer.appendChild(item);
                            console.log('No position specified, appended to end');
                        }
                        
                        // Return to normal appearance after animation
                        setTimeout(() => {
                            item.style.backgroundColor = '';
                            
                            // Reset transition after animation completes
                            setTimeout(() => {
                                item.style.transition = '';
                            }, 500);
                        }, 500);
                        
                        // Verify final position
                        const finalPosition = Array.from(targetContainer.children).indexOf(item);
                        console.log(`Final position verification: ${finalPosition} (expected ${newPosition})`);
                        
                        // Show a subtle notification that content was updated
                        const autoSaveIndicator = document.getElementById('auto-save-indicator');
                        autoSaveIndicator.innerHTML = 'Objekt flyttat';
                        setTimeout(() => {
                            autoSaveIndicator.innerHTML = '';
                        }, 2000);
                    } else {
                        console.error('Target risk column not found for level:', newRiskLevel);
                    }
                } else {
                    console.error('Entity row not found for entity:', entityId);
                }
            } else {
                console.error('Item not found for move:', { entityId, originalRiskLevel, itemId });
            }
        }

        // Broadcast item reorder within same risk level
        function broadcastItemReorder(entityId, riskLevel, itemId, newPosition) {
            console.log(`Broadcasting item reorder to position ${newPosition}`);
            
            // Verify position with a direct DOM check
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (!item) {
                console.error(`Item not found for reorder: ${entityId}, ${riskLevel}, ${itemId}`);
                return;
            }
            
            const container = item.parentNode;
            if (!container) {
                console.error(`Container not found for item: ${itemId}`);
                return;
            }
            
            // Force DOM position check - this is critical for accurate synchronization
            const actualPosition = Array.from(container.children).indexOf(item);
            
            // Store the position in a data attribute for verification
            item.setAttribute('data-position', actualPosition.toString());
            
            // Always use actual position from DOM to ensure accuracy
            if (actualPosition !== newPosition) {
                console.log(`Position correction: ${newPosition} → ${actualPosition}`);
                newPosition = actualPosition;
            }
            
            // Log all items in container for debugging
            console.log('Current container items:');
            Array.from(container.children).forEach((child, idx) => {
                console.log(`  [${idx}] ${child.getAttribute('data-item-id')} - ${child.querySelector('.item-text')?.textContent?.substring(0, 20) || 'no text'}`);
            });
            
            // Broadcast reorder with verified position
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'item_reorder',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    newPosition: newPosition, // Use verified position
                    timestamp: Date.now() // Add timestamp to help with ordering of events
                }
            }).then(() => {
                console.log('Item reorder broadcast sent successfully with position:', newPosition);
            }).catch(error => {
                console.error('Error broadcasting item reorder:', error);
            });
        }

        // Initialize drag and drop for all containers
        function initializeDragAndDrop() {
            // Initialize items
            const items = document.querySelectorAll('.item');
            items.forEach(item => {
                // Set draggable attribute to false initially
                item.setAttribute('draggable', 'false');
                // Initialize drag and drop for the item
                initializeDragForItem(item);
            });
            
            // Initialize containers
            const containers = document.querySelectorAll('.items-container');
            containers.forEach(container => {
                container.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    
                    // Don't allow dragging if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // Make sure the container is a valid drop target
                    // This is important for empty containers
                    if (draggedItem) {
                        // Remove drag-over class from all containers
                        const containers = document.querySelectorAll('.items-container');
                        containers.forEach(c => c.classList.remove('container-drag-over'));
                        
                        // Add drag-over class to this container
                        this.classList.add('container-drag-over');
                    }
                });
                
                container.addEventListener('drop', function(e) {
                    e.preventDefault();
                    
                    // Don't allow dropping if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // If we have a dragged item
                    if (draggedItem) {
                        console.log('Dropping directly on container:', this);
                        
                        // Remove container drag-over class
                        this.classList.remove('container-drag-over');
                        
                        // Get original position and risk level before moving
                        const originalRiskLevel = draggedItem.getAttribute('data-risk');
                        console.log('Original risk level:', originalRiskLevel);
                        
                        // Append to the container
                        this.appendChild(draggedItem);
                        
                        // Get new risk level after moving
                        const riskColumn = this.closest('.risk-column');
                        let newRiskLevel = originalRiskLevel;
                        if (riskColumn.classList.contains('no-risk')) newRiskLevel = 'No';
                        if (riskColumn.classList.contains('at-risk')) newRiskLevel = 'At';
                        if (riskColumn.classList.contains('high-risk')) newRiskLevel = 'High';
                        console.log('New risk level:', newRiskLevel);
                        
                        // Update the risk level attribute if it changed
                        if (newRiskLevel !== originalRiskLevel) {
                            console.log('Risk level changed, updating attribute and broadcasting');
                            draggedItem.setAttribute('data-risk', newRiskLevel);
                            
                            // Broadcast the move to other users
                            broadcastItemMove(
                                draggedItem.getAttribute('data-entity'),
                                originalRiskLevel,
                                newRiskLevel,
                                draggedItem.getAttribute('data-item-id')
                            );
                    } else {
                            console.log('Risk level unchanged, broadcasting reorder');
                            // Broadcast position change
                            broadcastItemReorder(
                                draggedItem.getAttribute('data-entity'),
                                newRiskLevel,
                                draggedItem.getAttribute('data-item-id'),
                                Array.from(this.children).indexOf(draggedItem)
                            );
                        }
                        
                        // Trigger auto-save to save the new order and risk level
                        triggerAutoSave();
                    }
                });
            });
            
            // Also initialize risk columns to handle drops directly on them
            const riskColumns = document.querySelectorAll('.risk-column');
            riskColumns.forEach(column => {
                column.addEventListener('dragover', function(e) {
                    // Don't allow dragging if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // Only handle if we're not already over an items-container
                    if (!e.target.closest('.items-container') && draggedItem) {
                        e.preventDefault();
                        
                        // Find the items container within this risk column
                        const container = this.querySelector('.items-container');
                        if (container) {
                            // Remove drag-over class from all containers
                            const containers = document.querySelectorAll('.items-container');
                            containers.forEach(c => c.classList.remove('container-drag-over'));
                            
                            // Add drag-over class to this container
                            container.classList.add('container-drag-over');
                        }
                    }
                });
                
                column.addEventListener('drop', function(e) {
                    // Don't allow dropping if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // Only handle if we're not already over an items-container
                    if (!e.target.closest('.items-container') && draggedItem) {
                        e.preventDefault();
                        
                        console.log('Dropping on risk column:', this);
                        
                        // Find the items container within this risk column
                        const container = this.querySelector('.items-container');
                        if (container) {
                            // Remove container drag-over class
                            container.classList.remove('container-drag-over');
                            
                            // Get original position and risk level before moving
                            const originalRiskLevel = draggedItem.getAttribute('data-risk');
                            console.log('Original risk level:', originalRiskLevel);
                            
                            // Append to the container
                            container.appendChild(draggedItem);
                            
                            // Get new risk level after moving
                            let newRiskLevel = originalRiskLevel;
                            if (this.classList.contains('no-risk')) newRiskLevel = 'No';
                            if (this.classList.contains('at-risk')) newRiskLevel = 'At';
                            if (this.classList.contains('high-risk')) newRiskLevel = 'High';
                            console.log('New risk level:', newRiskLevel);
                            
                            // Update the risk level attribute if it changed
                            if (newRiskLevel !== originalRiskLevel) {
                                console.log('Risk level changed, updating attribute and broadcasting');
                                draggedItem.setAttribute('data-risk', newRiskLevel);
                                
                                // Broadcast the move to other users
                                broadcastItemMove(
                                    draggedItem.getAttribute('data-entity'),
                                    originalRiskLevel,
                                    newRiskLevel,
                                    draggedItem.getAttribute('data-item-id')
                                );
                            } else {
                                console.log('Risk level unchanged, broadcasting reorder');
                                // Broadcast position change
                                broadcastItemReorder(
                                    draggedItem.getAttribute('data-entity'),
                                    newRiskLevel,
                                    draggedItem.getAttribute('data-item-id'),
                                    Array.from(container.children).indexOf(draggedItem)
                                );
                            }
                            
                            // Trigger auto-save to save the new order and risk level
                            triggerAutoSave();
                        }
                    }
                });
            });
        }

        // Load saved items when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Document ready, initializing app...');
            
            // Load saved items when page loads
            const savedItems = JSON.parse('{{ saved_items_json | safe }}' || '[]');
            
            // Sort items by position before loading
            savedItems.sort((a, b) => {
                // First group by entity and risk_level
                if (a.entity !== b.entity) return a.entity.localeCompare(b.entity);
                if (a.risk_level !== b.risk_level) return a.risk_level.localeCompare(b.risk_level);
                // Then sort by position
                return a.position - b.position;
            });
            
            savedItems.forEach(item => {
                if (item.category === currentCategory) {
                    // Find the correct container
                    const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
                    
                    if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                        
                        if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                            const itemElement = document.createElement('div');
                            itemElement.className = 'item';
                            itemElement.setAttribute('draggable', 'false');
                            itemElement.setAttribute('data-entity', item.entity);
                            itemElement.setAttribute('data-risk', item.risk_level);
                            itemElement.setAttribute('data-item-id', item.id || generateUUID());
                            itemElement.setAttribute('data-position', item.position.toString());
                            itemElement.setAttribute('data-category', item.category);
                            
                            // Use empty string if rating is null, undefined, or empty
                            const ratingValue = item.rating || '';
                            
                            itemElement.innerHTML = `
                                <i class="bi bi-grip-vertical drag-handle" title="Dra för att ändra ordning"></i>
                                <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text}</div>
                                <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                                <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                            `;
                            
                            // Insert at the correct position
                            if (item.position === 0) {
                                // Special case for position 0
                                container.insertBefore(itemElement, container.firstChild);
                            } else if (container.children.length > item.position) {
                                container.insertBefore(itemElement, container.children[item.position]);
                            } else {
                                container.appendChild(itemElement);
                            }
                            
                            // Add click handler to make text editable when clicked
                            const textElement = itemElement.querySelector('.item-text');
                            textElement.addEventListener('click', function(e) {
                                // Prevent editing if cell is being edited by another user
                                if (textElement.classList.contains('cell-editing-other')) {
                                    e.preventDefault();
                                    return;
                                }
                                
                                if (textElement.getAttribute('contenteditable') === 'false') {
                                    textElement.setAttribute('contenteditable', 'true');
                                    textElement.focus();
                                }
                            });
                            
                            // Initialize drag and drop for this item
                            initializeDragForItem(itemElement);
                        }
                    }
                }
            });
            
            // Setup realtime connections
            const channels = setupRealtimeSubscription();
            
            // Clean up subscription when page unloads
            window.addEventListener('beforeunload', () => {
                console.log('Cleaning up subscription...');
                
                // Broadcast that we stopped editing any cell
                if (currentlyEditingCell) {
                    broadcastEditingStatus(currentlyEditingCell, false);
                }
                
                channels.forEach(channel => {
                    supabaseClient.removeChannel(channel);
                });
            });
            
            // Initialize drag and drop
            initializeDragAndDrop();
            
            // Fix any position inconsistencies on initial load
            setTimeout(() => {
                // Update all position attributes to match actual DOM positions
                document.querySelectorAll('.items-container').forEach(container => {
                    Array.from(container.children).forEach((item, index) => {
                        item.setAttribute('data-position', index.toString());
                    });
                });
                
                console.log('Initial position synchronization complete');
            }, 1000);
            
            // Setup keyboard shortcuts
            setupKeyboardShortcuts();
            
            // Check welcome status
            if (!localStorage.getItem('welcomeShown')) {
                setTimeout(showWelcomeModal, 500);
            } else {
                if (localStorage.getItem('dragHintShown') === 'true') {
                    // Show help button immediately
                    showHelpButton();
                } else {
                    // Show drag hint after a short delay
                    setTimeout(showDragHint, 2000);
                }
            }
        });
        
        // Function to show welcome modal
        function showWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            modal.style.display = 'flex';
        }
        
        // Function to close welcome modal
        function closeWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            modal.style.display = 'none';
            
            // Mark as shown
            localStorage.setItem('welcomeShown', 'true');
            
            // Show drag hint after closing welcome modal
            setTimeout(showDragHint, 1000);
        }
        
        // Function to update welcome preference
        function updateWelcomePreference() {
            const checkbox = document.getElementById('dont-show-welcome');
            if (checkbox.checked) {
                localStorage.setItem('welcomeShown', 'true');
                } else {
                localStorage.removeItem('welcomeShown');
            }
        }
        
        // Tips for the drag hint popup
        // ... existing code ...
// ... existing code ...
const tips = [
    "Klicka på texten för att redigera, tryck Enter när du är klar.",
    "Klicka på bedömningsdelen för att sätta ett betyg.",
    "Tryck på plus-knappen för att lägga till ett nytt objekt.",
    "Du kan dra i cellen för att ändra ordning på objekten i riskkorten.",
    "Alla ändringar sparas automatiskt.",
    "Klicka på interventionsknappen <i class='bi bi-clipboard-check'></i> för att få förslag på åtgärder och insatser.",
    "Interventionsförslagen är kategoriserade för enklare navigering.",
    "Du kan söka bland interventionsförslagen med sökfunktionen.",
    "Du kan lägga till egna interventionsförslag genom att skriva in dem i rutan och trycka på plusknappen.",
    "Klicka på cellen för att kopiera interventionsförslaget till urklipp. De klistras in automatiskt när du trycker på plusknappen i ett riskkort.",
    "Dina egna interventionsförslag sparas och finns tillgängliga nästa gång du använder verktyget.",
// ... existing code ...
        ];
        
        let currentTipIndex = 0;
        
        // Function to show drag hint
        function showDragHint(forceShow = false) {
            if (forceShow || !localStorage.getItem('dragHintSeen')) {
                const dragHint = document.getElementById('drag-hint');
                dragHint.style.display = 'flex';
                
                // Set total tips counter
                document.getElementById('total-tips').textContent = tips.length;
                
                // Show first tip
                showTip(0);
                
                // Hide the help floating button
                document.getElementById('help-floating-btn').classList.remove('visible');
            }
        }
        
        // Function to show a specific tip
        function showTip(index) {
            // Ensure index is within bounds
            if (index < 0) index = tips.length - 1;
            if (index >= tips.length) index = 0;
            
            currentTipIndex = index;
            
            // Add fade out effect
            const tipText = document.getElementById('drag-hint-text');
            tipText.classList.add('fade');
            
            // Update content after short delay for transition
            setTimeout(() => {
                tipText.innerHTML = tips[index];
                document.getElementById('current-tip').textContent = index + 1;
                
                // Remove fade class to fade back in
                setTimeout(() => {
                    tipText.classList.remove('fade');
                }, 50);
            }, 200);
        }
        
        // Function to show next tip
        function nextTip() {
            showTip(currentTipIndex + 1);
        }
        
        // Function to show previous tip
        function previousTip() {
            showTip(currentTipIndex - 1);
        }
        
        // Function to close drag hint
        function closeDragHint() {
            document.getElementById('drag-hint').style.display = 'none';
            
            // Show the help button
            document.getElementById('help-floating-btn').classList.add('visible');
            
            // Mark as seen in localStorage
            localStorage.setItem('dragHintSeen', 'true');
        }
        
        // Function to show help button
        function showHelpButton() {
            const helpButton = document.getElementById('help-floating-btn');
            helpButton.classList.add('visible');
        }
        
        // Function to hide help button
        function hideHelpButton() {
            const helpButton = document.getElementById('help-floating-btn');
            helpButton.classList.remove('visible');
        }
        
        // Function to show shortcuts modal
        function showShortcutsModal() {
            const modal = document.getElementById('shortcuts-modal');
            modal.style.display = 'flex';
        }
        
        // Function to close shortcuts modal
        function closeShortcutsModal() {
            const modal = document.getElementById('shortcuts-modal');
            modal.style.display = 'none';
        }
        
        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Show shortcuts modal when '?' is pressed
            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                showShortcutsModal();
                e.preventDefault();
            }
            
            // Close modal with Escape key
            if (e.key === 'Escape' && document.getElementById('shortcuts-modal').style.display === 'flex') {
                closeShortcutsModal();
                e.preventDefault();
            }
            
            // Ctrl+S to save manually
            if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                saveDataToSupabase();
                e.preventDefault();
            }
            
            // Ctrl+N to add new item in the first column
            if (e.key === 'n' && (e.ctrlKey || e.metaKey)) {
                // Find the first add button and click it
                const firstAddButton = document.querySelector('.add-item-btn');
                if (firstAddButton) {
                    firstAddButton.click();
                }
                e.preventDefault();
            }
            
            // Delete key to remove selected item
            if (e.key === 'Delete' && currentlyEditingCell) {
                const item = currentlyEditingCell.closest('.item');
                if (item) {
                    const deleteButton = item.querySelector('.delete-btn');
                    if (deleteButton) {
                        deleteButton.click();
                    }
                }
            }
            
            // Enter key to finish editing
            if (e.key === 'Enter' && currentlyEditingCell) {
                currentlyEditingCell.blur();
                e.preventDefault();
            }
            
            // Tab key to show rating selector
            if (e.key === 'Tab' && !e.shiftKey) {
                // If we're currently editing a cell, finish editing and show rating selector
                if (currentlyEditingCell) {
                    e.preventDefault();
                    
                    // Finish editing
                    currentlyEditingCell.blur();
                    
                    // Wait a short moment for the blur event to complete
                    setTimeout(() => {
                        // Show rating selector for this item
                        const item = currentlyEditingCell.closest('.item');
                        if (item) {
                            const ratingCell = item.querySelector('.item-rating');
                            showRatingSelector(ratingCell);
                        }
                    }, 50);
                }
                // If a rating selector is already open, select the first option
                else if (document.getElementById('rating-selector').style.display === 'block') {
                    e.preventDefault();
                    
                    // Find the first rating option and click it
                    const firstOption = document.querySelector('.rating-option');
                    if (firstOption) {
                        firstOption.click();
                    }
                }
            }
        });
        
        // Close modal when clicking outside
        window.addEventListener('click', function(e) {
            const modal = document.getElementById('shortcuts-modal');
            if (e.target === modal) {
                closeShortcutsModal();
            }
        });

        // Handle new item
        function handleNewItem(payload) {
            console.log('New item update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId, position, category } = payload.payload;
            
            // Skip if category doesn't match current category
            if (category !== currentCategory) {
                console.log('Ignoring new item from different category:', category);
                return;
            }
            
            // Find the correct container
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent === entityId);
            
            if (entityRow) {
                const riskColumn = entityRow.querySelector(
                    riskLevel === 'No' ? '.no-risk' :
                    riskLevel === 'At' ? '.at-risk' :
                    '.high-risk'
                );
                
                if (riskColumn) {
                    const container = riskColumn.querySelector('.items-container');
                    
                    // Check if this item already exists (to avoid duplicates)
                    const existingItem = document.querySelector(`.item[data-item-id="${itemId}"]`);
                    if (!existingItem) {
                        // Create new item
                        const itemElement = document.createElement('div');
                        itemElement.className = 'item';
                        itemElement.setAttribute('draggable', 'false'); // Initially not draggable
                        itemElement.setAttribute('data-entity', entityId);
                        itemElement.setAttribute('data-risk', riskLevel);
                        itemElement.setAttribute('data-item-id', itemId);
                        itemElement.setAttribute('data-category', category || currentCategory); // Set category
                        
                        itemElement.innerHTML = `
                            <i class="bi bi-grip-vertical drag-handle" title="Dra för att ändra ordning"></i>
                            <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)"></div>
                            <div class="item-rating" onclick="showRatingSelector(this)"></div>
                            <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                        `;
                        
                        // Add to container at the specified position (or top if not specified)
                        if (position !== undefined && position < container.children.length) {
                            container.insertBefore(itemElement, container.children[position]);
                        } else {
                            container.insertBefore(itemElement, container.firstChild);
                        }
                        
                        // Add click handler to make text editable when clicked
                        const textElement = itemElement.querySelector('.item-text');
                        textElement.addEventListener('click', function(e) {
                            // Prevent editing if cell is being edited by another user
                            if (textElement.classList.contains('cell-editing-other')) {
                                e.preventDefault();
                                return;
                            }
                            
                            if (textElement.getAttribute('contenteditable') === 'false') {
                                textElement.setAttribute('contenteditable', 'true');
                                textElement.focus();
                            }
                        });
                        
                        // Initialize drag and drop for this item
                        initializeDragForItem(itemElement);
                        
                        // Show a subtle notification that content was updated
                        const autoSaveIndicator = document.getElementById('auto-save-indicator');
                        autoSaveIndicator.innerHTML = 'Nytt objekt tillagt';
                        setTimeout(() => {
                            autoSaveIndicator.innerHTML = '';
                        }, 2000);
                    }
                }
            }
        }

        // Handle item reorder within same risk level
        function handleItemReorder(payload) {
            console.log('Item reorder update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId, newPosition } = payload.payload;
            console.log(`Reordering item to position ${newPosition}`);
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                // Find the container
                const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                    .find(row => row.querySelector('.entity-title').textContent === entityId);
                
                if (entityRow) {
                    const riskColumn = entityRow.querySelector(
                        riskLevel === 'No' ? '.no-risk' :
                        riskLevel === 'At' ? '.at-risk' :
                        '.high-risk'
                    );
                    
                    if (riskColumn) {
                        const container = riskColumn.querySelector('.items-container');
                        
                        // Only reorder if not being edited
                        if (!item.querySelector('.cell-editing') && !item.querySelector('.cell-editing-other')) {
                            
                            // Get current position before any DOM manipulation
                            const currentPosition = Array.from(container.children).indexOf(item);
                            console.log(`Current position: ${currentPosition}, target position: ${newPosition}`);
                            
                            // Only proceed if we're actually changing position
                            if (currentPosition !== newPosition) {
                                // Prevent item from dragging during reordering
                                item.setAttribute('draggable', 'false');
                                
                                // Add a temporary visual indication
                                item.style.transition = 'all 0.5s ease';
                                item.style.backgroundColor = 'rgba(13, 110, 253, 0.1)';
                                
                                // Create a clone of the item to prevent flicker
                                const clone = item.cloneNode(true);
                                
                                // Store current children before removing the item
                                const currentChildren = Array.from(container.children);
                                
                                // Remove the original item temporarily
                                item.remove();
                                
                                // Now determine where to insert it based on stored references
                                if (newPosition === 0) {
                                    // Special case for position 0
                                    container.insertBefore(clone, container.firstChild);
                                } else if (newPosition >= currentChildren.length) {
                                    // If the position is at or beyond the end, append to the end
                                    container.appendChild(clone);
                                } else {
                                    // Handle the case where we're moving an item UP (smaller position number)
                                    if (newPosition < currentPosition) {
                                        // When moving up, insert before the item that was at newPosition
                                        container.insertBefore(clone, currentChildren[newPosition]);
                                    } else {
                                        // When moving down, we need to adjust for the removed item
                                        // If moving down, insert after the item that was at (newPosition-1)
                                        if (newPosition < currentChildren.length) {
                                            container.insertBefore(clone, currentChildren[newPosition]);
                                        } else {
                                            container.appendChild(clone);
                                        }
                                    }
                                }
                                
                                // Store the position in a data attribute for verification
                                clone.setAttribute('data-position', newPosition.toString());
                                
                                // Verify final position
                                const finalPosition = Array.from(container.children).indexOf(clone);
                                console.log(`Final position verification: ${finalPosition} (expected ${newPosition})`);
                                
                                // Add event listeners and restore functionality to the clone
                                initializeDragForItem(clone);
                                clone.querySelector('.item-text').addEventListener('click', function(e) {
                                    // Prevent editing if cell is being edited by another user
                                    if (this.classList.contains('cell-editing-other')) {
                                        e.preventDefault();
                                        return;
                                    }
                                    
                                    if (this.getAttribute('contenteditable') === 'false') {
                                        this.setAttribute('contenteditable', 'true');
                                        this.focus();
                                    }
                                });
                                
                                // Animate the transition
                                setTimeout(() => {
                                    clone.style.backgroundColor = '';
                                    
                                    // Reset transition after animation completes
                                    setTimeout(() => {
                                        clone.style.transition = '';
                                    }, 500);
                                }, 500);
                                
                                // Show a subtle notification that content was updated
                                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                                autoSaveIndicator.innerHTML = 'Ordning ändrad';
                                setTimeout(() => {
                                    autoSaveIndicator.innerHTML = '';
                                }, 2000);
                            }
                        }
                    }
                }
            }
        }

        // Search functionality
        document.getElementById('interventionSearch').addEventListener('input', function() {
            console.log('Search input triggered with value:', this.value); // Debug logging
            const searchTerm = this.value.toLowerCase().trim();
            const allItems = document.querySelectorAll('.intervention-item');
            const categories = document.querySelectorAll('.intervention-category');
            let foundAny = false;
            
            console.log('Total items to search through:', allItems.length); // Debug logging
            
            // Reset display before searching
            allItems.forEach(item => {
                // If empty search term, show all items
                if (searchTerm === '') {
                    item.style.display = 'flex';
                    foundAny = true;
                    return;
                }
                
                // Get the text content of the entire item to include all child nodes
                const itemText = item.textContent.toLowerCase().trim();
                
                // Also specifically check the intervention-text span if it exists
                const textElement = item.querySelector('.intervention-text');
                const spanText = textElement ? textElement.textContent.toLowerCase().trim() : '';
                
                // Show item if either the full text or the span text includes the search term
                if (itemText.includes(searchTerm) || spanText.includes(searchTerm)) {
                    item.style.display = 'flex';
                    foundAny = true;
                    console.log('Match found in item:', itemText); // Debug logging
                } else {
                    item.style.display = 'none';
                }
            });
            
            // Show/hide categories based on if they have visible items
            categories.forEach(category => {
                // Count items that are not hidden by the search
                const visibleItemCount = Array.from(category.querySelectorAll('.intervention-item'))
                    .filter(item => item.style.display !== 'none').length;
                
                console.log('Category:', category.querySelector('h4')?.textContent, 'visible items:', visibleItemCount);
                
                // Always show "Mina interventionsförslag" category, hide others if empty
                const categoryTitle = category.querySelector('h4')?.textContent || '';
                if (visibleItemCount === 0 && categoryTitle !== 'Mina interventionsförslag') {
                    category.style.display = 'none';
                } else {
                    category.style.display = 'block';
                }
            });
            
            // Show no results message if needed
            let noResultsMsg = document.getElementById('noResultsMsg');
            if (!noResultsMsg) {
                noResultsMsg = document.createElement('div');
                noResultsMsg.id = 'noResultsMsg';
                noResultsMsg.className = 'no-results';
                noResultsMsg.textContent = 'Inga resultat hittades';
                document.getElementById('interventionPanel').appendChild(noResultsMsg);
            }
            
            noResultsMsg.style.display = foundAny ? 'none' : 'block';
            
            // Debug info
            console.log('Search results - Found any matches:', foundAny);
        });
        
        // Add custom intervention
        document.getElementById('addInterventionBtn').addEventListener('click', function() {
            addCustomIntervention();
        });
        
        // Add intervention on Enter key
        document.getElementById('newIntervention').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCustomIntervention();
            }
        });
        
        // Save custom intervention to the database
        function saveCustomIntervention(text) {
            // Call API to save the intervention as a resource
            fetch('/add_resource', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: text
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('Intervention saved to database:', data.resource);
                } else {
                    console.error('Error saving intervention:', data.message);
                }
            })
            .catch(error => {
                console.error('Error saving intervention:', error);
            });
        }
        
        // Load custom interventions from API
        function loadCustomInterventions() {
            // Clear existing interventions to prevent duplicates on reload
            const customInterventionsList = document.getElementById('customInterventions');
            customInterventionsList.innerHTML = '';
            
            // Fetch interventions from API
            fetch('/api/interventions')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.interventions && data.interventions.length > 0) {
                        data.interventions.forEach(resource => {
                            // Create new intervention item
                            const li = document.createElement('li');
                            li.className = 'intervention-item';
                            
                            // Add icon
                            const icon = document.createElement('i');
                            icon.className = 'bi bi-check-circle';
                            icon.style.marginRight = '8px'; // Add spacing between icon and text
                            li.appendChild(icon);
                            
                            // Add text as a separate element for better control
                            const textSpan = document.createElement('span');
                            textSpan.textContent = resource.text;
                            textSpan.className = 'intervention-text';
                            textSpan.style.flex = '1'; // Take up available space
                            
                            // Store resource ID for later deletion
                            textSpan.dataset.resourceId = resource.id;
                            
                            li.appendChild(textSpan);
                            
                            // Add click event for copying on item click
                            li.addEventListener('click', function(e) {
                                // Ignore clicks on delete button
                                if (e.target.closest('.delete-intervention')) {
                                    return;
                                }
                                
                                // Get text from the span
                                const textToCopy = textSpan.textContent.trim();
                                
                                // Store this as the last copied text for auto-filling
                                window.lastCopiedText = textToCopy;
                                
                                // Copy to clipboard
                                navigator.clipboard.writeText(textToCopy).then(() => {
                                    // Add copied class
                                    li.classList.add('copied');
                                    
                                    // Remove copied class after a delay
                                    setTimeout(() => {
                                        li.classList.remove('copied');
                                    }, 2000);
                                    
                                    // Show tooltip
                                    const tooltip = document.createElement('div');
                                    tooltip.className = 'copy-tooltip';
                                    tooltip.textContent = 'Kopierad!';
                                    li.appendChild(tooltip);
                                    
                                    // Remove tooltip after animation
                                    setTimeout(() => {
                                        tooltip.remove();
                                    }, 2000);
                                    
                                    // Show auto-save indicator if it exists
                                    const autoSaveIndicator = document.getElementById('autoSaveIndicator');
                                    if (autoSaveIndicator) {
                                        autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                                        setTimeout(() => {
                                            autoSaveIndicator.innerHTML = '';
                                        }, 3000);
                                    }
                                }).catch(err => {
                                    console.error('Kunde inte kopiera text: ', err);
                                });
                            });
                            
                            // Add delete button
                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'delete-intervention';
                            deleteBtn.title = 'Ta bort';
                            deleteBtn.innerHTML = '<i class="bi bi-x-circle"></i>';
                            deleteBtn.style.marginLeft = 'auto';
                            deleteBtn.style.background = 'transparent';
                            deleteBtn.style.border = 'none';
                            deleteBtn.style.color = '#dc3545';
                            deleteBtn.style.padding = '5px 8px';
                            deleteBtn.addEventListener('click', function(e) {
                                e.stopPropagation();
                                li.remove();
                                
                                // Delete from database
                                fetch(`/delete_resource/${resource.id}`, {
                                    method: 'DELETE'
                                })
                                .then(response => response.json())
                                .then(data => {
                                    if (data.status === 'success') {
                                        console.log('Intervention deleted from database');
                                    } else {
                                        console.error('Error deleting intervention:', data.message);
                                    }
                                })
                                .catch(error => {
                                    console.error('Error deleting intervention:', error);
                                });
                            });
                            li.appendChild(deleteBtn);
                            
                            // Add to list
                            customInterventionsList.appendChild(li);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error loading interventions:', error);
                });
        }
    </script>

    <!-- Intervention Button and Panel -->
    <div class="intervention-btn" id="interventionBtn">
        <i class="bi bi-clipboard-check"></i>
    </div>

    <div class="intervention-panel" id="interventionPanel">
        <h3>Interventionsförslag</h3>
        
        <div class="search-container">
            <input type="text" id="interventionSearch" class="intervention-search" placeholder="Sök interventioner...">
        </div>
        
        <div class="add-custom-intervention" style="margin-bottom: 15px;">
            <input type="text" id="newIntervention" placeholder="Lägg till eget förslag...">
            <button id="addInterventionBtn"><i class="bi bi-plus-lg"></i></button>
        </div>
        
        <div class="intervention-category">
            <h4>Mina interventionsförslag</h4>
            <ul class="intervention-list" id="customInterventions">
                <!-- Anpassade interventionsförslag kommer läggas till här -->
            </ul>
        </div>
        
        <div class="intervention-category">
            <h4>Arbetsmiljö & Säkerhet</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Arbetsmiljögenomgång<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Introduktion till arbetsmiljö för nyanställda<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Arbetsmiljöpolicy<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Arbetsmiljöutbildning<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Årlig uppföljning av systematiskt arbetsmiljöarbete (SAM)<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Avvikelserapporteringssystem för arbetsmiljö<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Egeninspektion av arbetsmiljö<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Policy för alkohol och droger<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Systematiskt arbetsmiljöarbete och anpassningsprocesser<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Riskbedömningar på arbetsplatsen<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Samverkan med skyddsombud<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Visselblåsarsystem<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Ergonomisk arbetsplatsanalys<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>

        <div class="intervention-category">
            <h4>Hälsa & Friskvård</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Stresshanteringskurser<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Ergonomiskt stöd och utbildning<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Hälsosamtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Feelgoodsamtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Friskvårdsbidrag<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Hälsoundersökningar<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Medicinska kontroller<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Livsstilsverktyg<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Fysisk aktivitet på arbetstid<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Tillgång till företagshälsovård<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>

        <div class="intervention-category">
            <h4>Medarbetarstöd & Utveckling</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Regelbundna utvecklingssamtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Stödsamtal vid behov<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Coachning för medarbetare<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Kompetensutveckling<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Karriärplanering<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Mentorskapsprogram<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Krishantering och akut stöd<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Konflikthantering<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Förbättringsdialog<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Förmånsportal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>
        
        <div class="intervention-category">
            <h4>Ledarskap & Chefsstöd</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Ledarskapsutbildning för chefer<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Coachning för chefer<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Feedback-workshops<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Konflikthanteringsutbildning<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>HR Business Partner-stöd<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Stöd i svåra samtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Chefsenkät<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>

        <div class="intervention-category">
            <h4>Organisationsutveckling</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Teambuilding-aktiviteter<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Medarbetarundersökningar<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Förbättringsworkshops<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Optimering av arbetsflöden<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Delaktighetsmöten (APT)<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Mångfaldsarbete<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>

        <div class="intervention-category">
            <h4>Uppföljning & Rehabilitering</h4>
            <ul class="intervention-list">
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Sjukfrånvarouppföljning (kort- och långtidsfrånvaro)<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Rehabiliteringssamtal<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Rehabiliteringsplan<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Arbetsanpassning<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Uppföljningssystem för hälsoplaner<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
                <li class="intervention-item"><i class="bi bi-check-circle"></i>Tidig signalering vid upprepad sjukfrånvaro<button class="copy-btn" title="Kopiera"><i class="bi bi-clipboard"></i></button></li>
            </ul>
        </div>
    </div>

    <script>
        // Toggle intervention panel
        document.getElementById('interventionBtn').addEventListener('click', function() {
            document.getElementById('interventionPanel').classList.toggle('active');
        });

        // Close panel when clicking outside
        document.addEventListener('click', function(event) {
            const panel = document.getElementById('interventionPanel');
            const btn = document.getElementById('interventionBtn');
            
            if (!panel.contains(event.target) && event.target !== btn && !btn.contains(event.target)) {
                panel.classList.remove('active');
            }
        });

        // Drag and drop functionality for interventions
        document.addEventListener('DOMContentLoaded', function() {
            // Setup drag and drop for all intervention items
            setupDragAndDrop();
            
            // Load custom interventions
            loadCustomInterventions();
            
            // Setup copy buttons
            setupCopyButtons();
            
            // Track last copied text for auto-filling
            window.lastCopiedText = "";
            
            // Restore periodic cleanup to keep UI clean
            setInterval(function() {
                // If no drag operation is in progress (no element has 'dragging' class)
                if (!document.querySelector('.dragging')) {
                    // Clean up any cells that might still have the drag-over class
                    const riskCells = document.querySelectorAll('.no-risk, .at-risk, .high-risk');
                    riskCells.forEach(cell => {
                        if (cell.classList.contains('drag-over')) {
                            cell.classList.remove('drag-over');
                        }
                    });
                    
                    // Also clean up any container-drag-over classes
                    const containers = document.querySelectorAll('.container-drag-over');
                    containers.forEach(container => {
                        container.classList.remove('container-drag-over');
                    });
                }
            }, 2000); // Check every 2 seconds
        });
        
        function setupCopyButtons() {
            // Add click event to all copy buttons
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent item click
                    
                    // Get the text from the parent intervention item
                    const item = this.closest('.intervention-item');
                    const text = item.textContent.replace('Kopiera', '').trim();
                    
                    // Copy to clipboard
                    navigator.clipboard.writeText(text).then(() => {
                        // Save last copied text for auto-filling
                        window.lastCopiedText = text;
                        
                        // Show success message
                        const originalIcon = this.innerHTML;
                        this.innerHTML = '<i class="bi bi-check2"></i>';
                        this.title = 'Kopierad!';
                        
                        // Reset after a moment
                        setTimeout(() => {
                            this.innerHTML = originalIcon;
                            this.title = 'Kopiera';
                        }, 1500);
                        
                        // Show notification
                        const autoSaveIndicator = document.getElementById('auto-save-indicator');
                        if (autoSaveIndicator) {
                            autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                            setTimeout(() => {
                                autoSaveIndicator.innerHTML = '';
                            }, 2000);
                        }
                    }).catch(err => {
                        console.error('Kunde inte kopiera text: ', err);
                    });
                });
            });
        }
        
        function setupDragAndDrop() {
            const interventionItems = document.querySelectorAll('.intervention-item');
            
            interventionItems.forEach(item => {
                // Remove draggable attribute
                item.removeAttribute('draggable');
                
                // Make the entire item clickable to copy text
                item.addEventListener('click', function(e) {
                    // Only if not clicking the copy button or delete button
                    if (!e.target.closest('.copy-btn') && !e.target.closest('.delete-intervention')) {
                        const text = this.textContent.replace('Kopiera', '').trim();
                        
                        // Copy text to clipboard
                        navigator.clipboard.writeText(text).then(() => {
                            // Store the last copied text for auto-filling
                            window.lastCopiedText = text;
                            
                            // Show tooltip notification
                            showCopyTooltip(this, 'Kopierad! Tryck på plus-knappen i en riskcell för att lägga till texten');
                            
                            // Show notification in auto-save indicator
                            const autoSaveIndicator = document.getElementById('auto-save-indicator');
                            if (autoSaveIndicator) {
                                autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                                setTimeout(() => {
                                    autoSaveIndicator.innerHTML = '';
                                }, 2000);
                            }
                        }).catch(err => {
                            console.error('Kunde inte kopiera text: ', err);
                        });
                    }
                });
            });
            
            // Restore drag functionality for items in risk cells
            const riskItems = document.querySelectorAll('.risk-column .item');
            riskItems.forEach(item => {
                // Ensure the item is draggable
                item.setAttribute('draggable', 'true');
                // Initialize drag and drop
                initializeDragForItem(item);
            });
            
            // Make sure risk cells can handle the dropping
            const riskCells = document.querySelectorAll('.no-risk, .at-risk, .high-risk');
            riskCells.forEach(cell => {
                // Ensure no drag-over classes are left
                cell.classList.remove('drag-over');
            });
        }
        
        // Helper function to show a tooltip on an intervention item
        function showCopyTooltip(element, message) {
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'copy-tooltip';
            tooltip.textContent = message;
            
            // Position tooltip
            element.style.position = 'relative';
            element.appendChild(tooltip);
            
            // Apply a highlight effect to the item
            element.classList.add('copied');
            
            // Remove tooltip after 3.5 seconds
            setTimeout(() => {
                tooltip.remove();
                // Don't remove copied class here since we're already handling it in the click event
            }, 3500);
        }
        
        function handleDragStart(e) {
            // Add a class to show it's being dragged
            this.classList.add('dragging');
            
            // Set the data being dragged
            // Get only the text content, excluding the rating
            const textOnly = this.querySelector('.item-text') ? 
                this.querySelector('.item-text').textContent : 
                this.textContent.replace('Kopiera', '').trim();
            
            e.dataTransfer.setData('text/plain', textOnly);
            
            // Set how it looks when dragged
            if (e.dataTransfer.setDragImage) {
                const dragIcon = document.createElement('div');
                dragIcon.textContent = textOnly;
                dragIcon.style.backgroundColor = '#5D6D7E';
                dragIcon.style.color = 'white';
                dragIcon.style.padding = '10px';
                dragIcon.style.borderRadius = '6px';
                dragIcon.style.position = 'absolute';
                dragIcon.style.top = '-1000px';
                document.body.appendChild(dragIcon);
                
                e.dataTransfer.setDragImage(dragIcon, 0, 0);
                
                // Remove the temporary element after a bit
                setTimeout(() => {
                    document.body.removeChild(dragIcon);
                }, 0);
            }
            
            // Listen for drag end
            this.addEventListener('dragend', function() {
                this.classList.remove('dragging');
            }, { once: true });
        }
        
        function createStandardItem(cell, interventionText) {
            // This is a fallback in case addNewItem function doesn't exist
            // Try to mimic how new items are normally created
            
            // If no intervention text is provided, use the last copied text if available
            if (!interventionText && window.lastCopiedText) {
                interventionText = window.lastCopiedText;
                // Clear it so it's only used once
                window.lastCopiedText = "";
            }
            
            // If still no text, return without creating an item
            if (!interventionText) {
                return;
            }
            
            // Clean the text (remove icon text and copy button text)
            const cleanText = interventionText.replace(/^[\u2713\u2714\✓\✔\u2705\u25A0\•\◦\-\+\*]+\s*/, '').replace('Kopiera', '').trim();
            
            // Check if cell is part of the current visible category/tab
            const row = cell.closest('.entity-row');
            if (!row || row.getAttribute('data-category') !== currentCategory) {
                console.log('Not adding intervention to cell of different category');
                return;
            }
            
            // Create an input element to simulate user input
            const fakeInput = document.createElement('input');
            fakeInput.value = cleanText;
            
            // Try to find the add button in the cell and trigger its click handler
            const addBtn = cell.querySelector('.add-item-btn');
            if (addBtn) {
                // Create a custom event
                const clickEvent = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                
                // Set current input field for the handlers
                window.currentAddInput = fakeInput;
                
                // Dispatch the event
                addBtn.dispatchEvent(clickEvent);
            } else {
                // Fallback to manual insertion
                console.log('No add button found, manually inserting item');
                
                // Create a new item based on others in the cell
                const container = cell.querySelector('.items-container');
                if (container) {
                    // Create a new element similar to existing ones
                    const newItem = document.createElement('div');
                    newItem.className = 'item';
                    newItem.setAttribute('draggable', 'true');
                    newItem.setAttribute('data-category', currentCategory);
                    
                    // Create content element
                    const content = document.createElement('div');
                    content.className = 'item-content';
                    content.textContent = cleanText;
                    newItem.appendChild(content);
                    
                    // Add delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '<i class="bi bi-x"></i>';
                    deleteBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        newItem.remove();
                    });
                    newItem.appendChild(deleteBtn);
                    
                    // Add to container
                    container.appendChild(newItem);
                }
            }
            
            // Show notification
            const autoSaveIndicator = document.getElementById('auto-save-indicator');
            if (autoSaveIndicator) {
                autoSaveIndicator.innerHTML = 'Intervention tillagd';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Function to add custom intervention
        function addCustomIntervention() {
            const input = document.getElementById('newIntervention');
            const text = input.value.trim();
            
            if (text) {
                // Save to database first
                saveCustomIntervention(text);
                
                // Create new intervention item in UI
                const li = document.createElement('li');
                li.className = 'intervention-item';
                
                // Add icon
                const icon = document.createElement('i');
                icon.className = 'bi bi-check-circle';
                icon.style.marginRight = '8px'; // Add spacing between icon and text
                li.appendChild(icon);
                
                // Add text as a separate element for better control
                const textSpan = document.createElement('span');
                textSpan.textContent = text;
                textSpan.className = 'intervention-text';
                textSpan.style.flex = '1'; // Take up available space
                li.appendChild(textSpan);
                
                // Add click event for copying on item click
                li.addEventListener('click', function(e) {
                    // Ignore clicks on delete button
                    if (e.target.closest('.delete-intervention')) {
                        return;
                    }
                    
                    // Get text from the span
                    const textToCopy = textSpan.textContent.trim();
                    
                    // Store this as the last copied text for auto-filling
                    window.lastCopiedText = textToCopy;
                    
                    // Copy to clipboard
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        // Add copied class
                        li.classList.add('copied');
                        
                        // Remove copied class after a delay
                        setTimeout(() => {
                            li.classList.remove('copied');
                        }, 2000);
                        
                        // Show tooltip
                        const tooltip = document.createElement('div');
                        tooltip.className = 'copy-tooltip';
                        tooltip.textContent = 'Kopierad!';
                        li.appendChild(tooltip);
                        
                        // Remove tooltip after animation
                        setTimeout(() => {
                            tooltip.remove();
                        }, 2000);
                        
                        // Show auto-save indicator if it exists
                        const autoSaveIndicator = document.getElementById('autoSaveIndicator');
                        if (autoSaveIndicator) {
                            autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                            setTimeout(() => {
                                autoSaveIndicator.innerHTML = '';
                            }, 3000);
                        }
                    }).catch(err => {
                        console.error('Kunde inte kopiera text: ', err);
                    });
                });
                
                // Add delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-intervention';
                deleteBtn.title = 'Ta bort';
                deleteBtn.innerHTML = '<i class="bi bi-x-circle"></i>';
                deleteBtn.style.marginLeft = 'auto';
                deleteBtn.style.background = 'transparent';
                deleteBtn.style.border = 'none';
                deleteBtn.style.color = '#dc3545';
                deleteBtn.style.padding = '5px 8px';
                deleteBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    li.remove();
                    
                    // Delete from database by calling the API endpoint
                    if (textSpan.dataset.resourceId) {
                        fetch(`/delete_resource/${textSpan.dataset.resourceId}`, {
                            method: 'DELETE'
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success') {
                                console.log('Intervention deleted from database');
                            } else {
                                console.error('Error deleting intervention:', data.message);
                            }
                        })
                        .catch(error => {
                            console.error('Error deleting intervention:', error);
                        });
                    }
                });
                li.appendChild(deleteBtn);
                
                // Add to list
                document.getElementById('customInterventions').appendChild(li);
                
                // Clear input
                input.value = '';
            }
        }
        
        // Search functionality
        document.getElementById('interventionSearch').addEventListener('input', function() {
            console.log('Search input triggered with value:', this.value); // Debug logging
            const searchTerm = this.value.toLowerCase().trim();
            const allItems = document.querySelectorAll('.intervention-item');
            const categories = document.querySelectorAll('.intervention-category');
            let foundAny = false;
            
            console.log('Total items to search through:', allItems.length); // Debug logging
            
            // Reset display before searching
            allItems.forEach(item => {
                // If empty search term, show all items
                if (searchTerm === '') {
                    item.style.display = 'flex';
                    foundAny = true;
                    return;
                }
                
                // Get the text content of the entire item to include all child nodes
                const itemText = item.textContent.toLowerCase().trim();
                
                // Also specifically check the intervention-text span if it exists
                const textElement = item.querySelector('.intervention-text');
                const spanText = textElement ? textElement.textContent.toLowerCase().trim() : '';
                
                // Show item if either the full text or the span text includes the search term
                if (itemText.includes(searchTerm) || spanText.includes(searchTerm)) {
                    item.style.display = 'flex';
                    foundAny = true;
                    console.log('Match found in item:', itemText); // Debug logging
                } else {
                    item.style.display = 'none';
                }
            });
            
            // Show/hide categories based on if they have visible items
            categories.forEach(category => {
                // Count items that are not hidden by the search
                const visibleItemCount = Array.from(category.querySelectorAll('.intervention-item'))
                    .filter(item => item.style.display !== 'none').length;
                
                console.log('Category:', category.querySelector('h4')?.textContent, 'visible items:', visibleItemCount);
                
                // Always show "Mina interventionsförslag" category, hide others if empty
                const categoryTitle = category.querySelector('h4')?.textContent || '';
                if (visibleItemCount === 0 && categoryTitle !== 'Mina interventionsförslag') {
                    category.style.display = 'none';
                } else {
                    category.style.display = 'block';
                }
            });
            
            // Show no results message if needed
            let noResultsMsg = document.getElementById('noResultsMsg');
            if (!noResultsMsg) {
                noResultsMsg = document.createElement('div');
                noResultsMsg.id = 'noResultsMsg';
                noResultsMsg.className = 'no-results';
                noResultsMsg.textContent = 'Inga resultat hittades';
                document.getElementById('interventionPanel').appendChild(noResultsMsg);
            }
            
            noResultsMsg.style.display = foundAny ? 'none' : 'block';
            
            // Debug info
            console.log('Search results - Found any matches:', foundAny);
        });
        
        // Add custom intervention
        document.getElementById('addInterventionBtn').addEventListener('click', function() {
            addCustomIntervention();
        });
        
        // Add intervention on Enter key
        document.getElementById('newIntervention').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addCustomIntervention();
            }
        });
        
        // Save custom intervention to the database
        function saveCustomIntervention(text) {
            // Call API to save the intervention as a resource
            fetch('/add_resource', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: text
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    console.log('Intervention saved to database:', data.resource);
                } else {
                    console.error('Error saving intervention:', data.message);
                }
            })
            .catch(error => {
                console.error('Error saving intervention:', error);
            });
        }
        
        // Load custom interventions from API
        function loadCustomInterventions() {
            // Clear existing interventions to prevent duplicates on reload
            const customInterventionsList = document.getElementById('customInterventions');
            customInterventionsList.innerHTML = '';
            
            // Fetch interventions from API
            fetch('/api/interventions')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.interventions && data.interventions.length > 0) {
                        data.interventions.forEach(resource => {
                            // Create new intervention item
                            const li = document.createElement('li');
                            li.className = 'intervention-item';
                            
                            // Add icon
                            const icon = document.createElement('i');
                            icon.className = 'bi bi-check-circle';
                            icon.style.marginRight = '8px'; // Add spacing between icon and text
                            li.appendChild(icon);
                            
                            // Add text as a separate element for better control
                            const textSpan = document.createElement('span');
                            textSpan.textContent = resource.text;
                            textSpan.className = 'intervention-text';
                            textSpan.style.flex = '1'; // Take up available space
                            
                            // Store resource ID for later deletion
                            textSpan.dataset.resourceId = resource.id;
                            
                            li.appendChild(textSpan);
                            
                            // Add click event for copying on item click
                            li.addEventListener('click', function(e) {
                                // Ignore clicks on delete button
                                if (e.target.closest('.delete-intervention')) {
                                    return;
                                }
                                
                                // Get text from the span
                                const textToCopy = textSpan.textContent.trim();
                                
                                // Store this as the last copied text for auto-filling
                                window.lastCopiedText = textToCopy;
                                
                                // Copy to clipboard
                                navigator.clipboard.writeText(textToCopy).then(() => {
                                    // Add copied class
                                    li.classList.add('copied');
                                    
                                    // Remove copied class after a delay
                                    setTimeout(() => {
                                        li.classList.remove('copied');
                                    }, 2000);
                                    
                                    // Show tooltip
                                    const tooltip = document.createElement('div');
                                    tooltip.className = 'copy-tooltip';
                                    tooltip.textContent = 'Kopierad!';
                                    li.appendChild(tooltip);
                                    
                                    // Remove tooltip after animation
                                    setTimeout(() => {
                                        tooltip.remove();
                                    }, 2000);
                                    
                                    // Show auto-save indicator if it exists
                                    const autoSaveIndicator = document.getElementById('autoSaveIndicator');
                                    if (autoSaveIndicator) {
                                        autoSaveIndicator.innerHTML = 'Text kopierad till urklipp';
                                        setTimeout(() => {
                                            autoSaveIndicator.innerHTML = '';
                                        }, 3000);
                                    }
                                }).catch(err => {
                                    console.error('Kunde inte kopiera text: ', err);
                                });
                            });
                            
                            // Add delete button
                            const deleteBtn = document.createElement('button');
                            deleteBtn.className = 'delete-intervention';
                            deleteBtn.title = 'Ta bort';
                            deleteBtn.innerHTML = '<i class="bi bi-x-circle"></i>';
                            deleteBtn.style.marginLeft = 'auto';
                            deleteBtn.style.background = 'transparent';
                            deleteBtn.style.border = 'none';
                            deleteBtn.style.color = '#dc3545';
                            deleteBtn.style.padding = '5px 8px';
                            deleteBtn.addEventListener('click', function(e) {
                                e.stopPropagation();
                                li.remove();
                                
                                // Delete from database
                                fetch(`/delete_resource/${resource.id}`, {
                                    method: 'DELETE'
                                })
                                .then(response => response.json())
                                .then(data => {
                                    if (data.status === 'success') {
                                        console.log('Intervention deleted from database');
                                    } else {
                                        console.error('Error deleting intervention:', data.message);
                                    }
                                })
                                .catch(error => {
                                    console.error('Error deleting intervention:', error);
                                });
                            });
                            li.appendChild(deleteBtn);
                            
                            // Add to list
                            customInterventionsList.appendChild(li);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error loading interventions:', error);
                });
        }
    </script>
</body>
</html>
